<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>文章列表 on 码农Joseph</title>
		<link>https://zhangxuesong.github.io/posts/</link>
		<description>Recent content in 文章列表 on 码农Joseph</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en</language>
		<copyright>本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，转载请注明 码农Joseph 和出处链接。</copyright>
		<lastBuildDate>Sat, 26 Dec 2020 18:54:51 +0800</lastBuildDate>
		<atom:link href="https://zhangxuesong.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>sync.WaitGroup 和 sync.Once</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_sync_waitgroup/</link>
			<pubDate>Sat, 26 Dec 2020 18:54:51 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_sync_waitgroup/</guid>
			<description>sync 包的 WaitGroup 类型 主 goroutine 等待其他手动启动的 goroutine 时可以考虑 sync.WaitGroup 类型，它比通道更适合实现这种一对多的 goroutine 协作流程。 sync.WaitGroup 是开箱即用的，也是并发安全的。同时，它一旦</description>
			<content type="html"><![CDATA[<h2 id="sync-包的-waitgroup-类型">sync 包的 WaitGroup 类型</h2>
<p>主 goroutine 等待其他手动启动的 goroutine 时可以考虑 sync.WaitGroup 类型，它比通道更适合实现这种一对多的 goroutine 协作流程。</p>
<p>sync.WaitGroup 是开箱即用的，也是并发安全的。同时，它一旦被真正使用就不能被复制了。它有三个指针方法：Add、Done 和 Wait。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A WaitGroup waits for a collection of goroutines to finish.
</span><span class="c1">// The main goroutine calls Add to set the number of
</span><span class="c1">// goroutines to wait for. Then each of the goroutines
</span><span class="c1">// runs and calls Done when finished. At the same time,
</span><span class="c1">// Wait can be used to block until all goroutines have finished.
</span><span class="c1">//
</span><span class="c1">// A WaitGroup must not be copied after first use.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">WaitGroup</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">noCopy</span> <span class="nx">noCopy</span>

	<span class="c1">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.
</span><span class="c1"></span>	<span class="c1">// 64-bit atomic operations require 64-bit alignment, but 32-bit
</span><span class="c1"></span>	<span class="c1">// compilers do not ensure it. So we allocate 12 bytes and then use
</span><span class="c1"></span>	<span class="c1">// the aligned 8 bytes in them as state, and the other 4 as storage
</span><span class="c1"></span>	<span class="c1">// for the sema.
</span><span class="c1"></span>	<span class="nx">state1</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></div><p>我们可以想象它有一个计数器，默认值是 0。可以通过 Add 方法来增加或减少计数器的值。一般用来记录需要等待的 goroutine 数量。</p>
<p>它的 Done 方法用于对计数器的值进行减一操作，我们可以在需要等待的 goroutine 中通过 defer 语句调用它。</p>
<p>Wait 方法用于阻塞当前 goroutine，直到其所属值中的计数器归零。如果该方法被调用时计数器就是 0，它将不会做任何事。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;sync/atomic&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="nx">num</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">max</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
	<span class="nf">addNum</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">num</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">max</span><span class="p">,</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">)</span>
	<span class="nf">addNum</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">num</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">max</span><span class="p">,</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">addNum</span><span class="p">(</span><span class="nx">num</span> <span class="o">*</span><span class="kt">int32</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">max</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">deferFunc</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">deferFunc</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">currNum</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt32</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">currNum</span> <span class="o">&gt;=</span> <span class="nx">max</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">newNum</span> <span class="o">:=</span> <span class="nx">currNum</span> <span class="o">+</span> <span class="mi">2</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Nanosecond</span> <span class="o">*</span> <span class="mi">200</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span> <span class="nx">currNum</span><span class="p">,</span> <span class="nx">newNum</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The number: %d [%d-%d]\n&#34;</span><span class="p">,</span> <span class="nx">newNum</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The CAS operation failed. [%d-%d]\n&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>首先声明了一个 WaitGroup 类型的变量 wg。然后，调用了它的 Add 方法并传入了 2，因为后面会启用两个需要等待的 goroutine。</p>
<p>由于 wg 变量的 Done 方法本身就是一个既无参数声明，也无结果声明的函数，所以在 go 语句中调用 addNum 函数的时候，可以直接把该方法作为最后一个参数值传进去。</p>
<p>最后，调用了 wg 的 Wait 方法。如此一来，该函数就可以等到那两个 goroutine 都运行结束之后，再结束执行了。</p>
<p>以上就是 WaitGroup 类型最典型的应用场景了。</p>
<h2 id="syncwaitgroup-类型值的计数器">sync.WaitGroup 类型值的计数器</h2>
<p>计数器的值是不可以小于 0 的，这样会引发一个 panic，不适当的调用这类值的 Done 和 Add 方法都会如此。Add 方法是可以传入负数的。</p>
<p>我们声明了这样一个变量后，应该首先根据需要等待的 goroutine 或者其他事件的数量调用它的 Add 方法，以使它的计数器大于 0。这是确保我们能在后面正常的使用这类值的前提。</p>
<p>如果我们对它的 Add 方法的首次调用与对它的 Wait 方法的调用是同时发起的，比如，同时启动的两个 goroutine 中，分别调用这两个方法，那么就有可能让这里的 Add 方法抛出一个 panic。</p>
<p>这种情况不容易复现，我们更应该重视。虽然 sync.WaitGroup 值本身不需要初始化，但是尽早增加计数器的值还是很有必要的。</p>
<p>另外，WaitGroup 值是可以复用的，但是需要保证其计数周期的完整性。计数周期是指：该值中的计数器值由 0 变为某个正整数，经过一系列的变化之后，最终又变回 0。</p>
<p>就是说，计数器的值始于 0 又归于 0，就可以被视为一个计数周期。在一个此类值的生命周期中，它可以经历任意多个计数周期。但是只有当它走完当前的计数周期后，才可以开始下一个计数周期。</p>
<p><p class="md__image">
  <img src=".././image/fac7dfa184053d2a95e121aa17141d8d.png"
    alt=""  />
</p>
</p>
<p>因此，也可以说，如果此类值的 Wait 方法在它某个计数周期中被调用，就会立即阻塞当前 goroutine，直到这个计数周期完成。然后该值的下一个计数周期必须等待 Wait 方法执行结束后才能够开始。如果在一个此类值的 Wait 方法被执行期间，跨越了两个计数周期，就会引发一个 panic。</p>
<p>例如，在当前的 goroutine 因调用此类值的 Wait 方法，而被阻塞的时候，另一个 goroutine 调用了该值的 Done 方法，并使其计数器的值变为了 0。</p>
<p>这会唤醒当前的 goroutine，并使它试图继续执行 Wait 方法中其余的代码。但在这时，又有一个 goroutine 调用了它的 Add 方法，并让其计数器的值又从 0 变为了某个正整数。此时，这里的 Wait 方法就会立即抛出一个 panic。</p>
<p>纵观上述会引发 panic 的后两种情况，我们可以总结出这样一条关于 WaitGroup 值的使用禁忌，即：不要把增加其计数器值的操作和调用其 Wait 方法的代码，放在不同的 goroutine 中执行。换句话说，要杜绝对同一个 WaitGroup 值的两种操作的并发执行。</p>
<h2 id="synconce-类型值的-do-方法怎样保证只执行一次">sync.Once 类型值的 Do 方法怎样保证只执行一次</h2>
<p>与 sync.WaitGroup 类型一样，sync.Once 类型也属于结构体类型，也是开箱即用和并发安全的。由于该类型中包含了一个 sync.Mutex 类型的字段，所以也是不能复制的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Once is an object that will perform exactly one action.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Once</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// done indicates whether the action has been performed.
</span><span class="c1"></span>	<span class="c1">// It is first in the struct because it is used in the hot path.
</span><span class="c1"></span>	<span class="c1">// The hot path is inlined at every call site.
</span><span class="c1"></span>	<span class="c1">// Placing done first allows more compact instructions on some architectures (amd64/x86),
</span><span class="c1"></span>	<span class="c1">// and fewer instructions (to calculate offset) on other architectures.
</span><span class="c1"></span>	<span class="nx">done</span> <span class="kt">uint32</span>
	<span class="nx">m</span>    <span class="nx">Mutex</span>
<span class="p">}</span>
</code></pre></div><p>Once 类型的 Do 方法只接受一个参数，这个参数的类型必须是 func()，即：无参数声明和结果声明的函数。</p>
<p>该方法的功能并不是对每一种参数函数都只执行一次，而是只执行首次被调用时传入的那个函数，并且之后不会再执行任何参数函数。</p>
<p>所以，如果有多个只需要执行一次的函数，那么就应该为它们中的每一个都分配一个 sync.Once 类型的值。</p>
<p>Once 类型中还有一个名叫 done 的 uint32 类型的字段。它的作用是记录其所属值的 Do 方法被调用的次数。不过，该字段的值只可能是0 或者 1。一旦 Do 方法的首次调用完成，它的值就会从 0 变为 1。</p>
<p>并且因为对它的操作必须是原子的。Do 方法在一开始就会通过调用 atomic.LoadUint32 函数来获取该字段的值，并且一旦发现该值为1，就会直接返回。这也初步保证了 Do 方法，只会执行首次被调用时传入的函数。</p>
<p>不过，单凭这样一个判断的保证是不够的。因为，如果有两个 goroutine 都调用了同一个新的 Once 值的 Do 方法，并且几乎同时执行到了其中的这个条件判断代码，那么它们就都会因判断结果为 false，而继续执行 Do 方法中剩余的代码。</p>
<p>在这个条件判断之后，Do 方法会立即锁定其所属值中的那个 sync.Mutex 类型的字段 m。然后，它会在临界区中再次检查 done 字段的值，并且仅在条件满足时，才会去调用参数函数，以及用原子操作把 done 的值变为 1。</p>
<p>这个 Do 方法的实现方式，与单例模式有很多相似之处。它们都会先在临界区之外，判断一次关键条件，若条件不满足则立即返回。这通常被称为 快路径或者快速失败路径。</p>
<p>如果条件满足，那么到了临界区中还要再对关键条件进行一次判断，这主要是为了更加严谨。这两次条件判断常被统称为（跨临界区的）双重检查。</p>
<p>由于进入临界区之前，肯定要锁定保护它的互斥锁 m，显然会降低代码的执行速度，所以其中的第二次条件判断，以及后续的操作就被称为慢路径或者常规路径。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Do calls the function f if and only if Do is being called for the
</span><span class="c1">// first time for this instance of Once. In other words, given
</span><span class="c1">// 	var once Once
</span><span class="c1">// if once.Do(f) is called multiple times, only the first call will invoke f,
</span><span class="c1">// even if f has a different value in each invocation. A new instance of
</span><span class="c1">// Once is required for each function to execute.
</span><span class="c1">//
</span><span class="c1">// Do is intended for initialization that must be run exactly once. Since f
</span><span class="c1">// is niladic, it may be necessary to use a function literal to capture the
</span><span class="c1">// arguments to a function to be invoked by Do:
</span><span class="c1">// 	config.once.Do(func() { config.init(filename) })
</span><span class="c1">//
</span><span class="c1">// Because no call to Do returns until the one call to f returns, if f causes
</span><span class="c1">// Do to be called, it will deadlock.
</span><span class="c1">//
</span><span class="c1">// If f panics, Do considers it to have returned; future calls of Do return
</span><span class="c1">// without calling f.
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="c1">// Note: Here is an incorrect implementation of Do:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//	if atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) {
</span><span class="c1"></span>	<span class="c1">//		f()
</span><span class="c1"></span>	<span class="c1">//	}
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Do guarantees that when it returns, f has finished.
</span><span class="c1"></span>	<span class="c1">// This implementation would not implement that guarantee:
</span><span class="c1"></span>	<span class="c1">// given two simultaneous calls, the winner of the cas would
</span><span class="c1"></span>	<span class="c1">// call f, and the second would return immediately, without
</span><span class="c1"></span>	<span class="c1">// waiting for the first&#39;s call to f to complete.
</span><span class="c1"></span>	<span class="c1">// This is why the slow path falls back to a mutex, and why
</span><span class="c1"></span>	<span class="c1">// the atomic.StoreUint32 must be delayed until after f returns.
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Outlined slow-path to allow inlining of the fast-path.
</span><span class="c1"></span>		<span class="nx">o</span><span class="p">.</span><span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="nf">f</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="do-方法的两个特点">Do 方法的两个特点</h3>
<p>第一个特点，由于 Do 方法只会在参数函数执行结束之后把 done 字段的值变为 1，因此，如果参数函数的执行需要很长时间或者根本就不会结束（比如执行一些守护任务），那么就有可能会导致相关 goroutine 的同时阻塞。</p>
<p>例如，有多个 goroutine 并发地调用了同一个 Once 值的 Do 方法，并且传入的函数都会一直执行而不结束。那么，这些 goroutine 就都会因调用了这个 Do 方法而阻塞。因为，除了那个抢先执行了参数函数的 goroutine 之外，其他的 goroutine 都会被阻塞在锁定该 Once 值的互斥锁 m 的那行代码上。</p>
<p>第二个特点，Do 方法在参数函数执行结束后，对 done 字段的赋值用的是原子操作，并且，这一操作是被挂在 defer 语句中的。因此，不论参数函数的执行会以怎样的方式结束，done 字段的值都会变为 1。</p>
<p>也就是说，即使这个参数函数没有执行成功（比如引发了一个 panic），我们也无法使用同一个 Once 值重新执行它了。所以，如果你需要为参数函数的执行设定重试机制，那么就要考虑 Once 值的适时替换问题。</p>
]]></content>
		</item>
		
		<item>
			<title>原子操作 sync/atomic 2</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_sync_atomic2/</link>
			<pubDate>Fri, 25 Dec 2020 19:52:27 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_sync_atomic2/</guid>
			<description>比较并交换和比较有什么不同 比较并交换操作即 CAS 操作，是有条件的交换操作，只有在条件满足的情况下才会进行交换操作。 所谓的交换指的是，把新值赋给变</description>
			<content type="html"><![CDATA[<h2 id="比较并交换和比较有什么不同">比较并交换和比较有什么不同</h2>
<p>比较并交换操作即 CAS 操作，是有条件的交换操作，只有在条件满足的情况下才会进行交换操作。</p>
<p>所谓的交换指的是，把新值赋给变量，并返回变量的旧值。</p>
<p>在进行 CAS 操作时，函数会先判断被操作变量的当前值是否与我们预期的旧值相等。如果相等就把新值赋给变量，并返回 true 表明交换操作已进行，否则就忽略交换操作，返回 false。</p>
<p>CAS 操作并不是单一操作，而是一种操作组合。和其他的原子操作不同，它的用途更加广泛。例如，跟 for 语句联用可以实现自旋锁（spinlock）。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">num</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;The number has gone to zero.&#34;</span><span class="p">)</span>
    <span class="k">break</span>
  <span class="p">}</span>
  <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>for 语句中的 CAS 操作不停的检查某个需要满足的条件，一旦满足条件就退出 for 循环。只要条件未被满足，当前的流程就一直阻塞在这里。</p>
<p>所以使用 CAS 操作的时候，我们还是要多加注意的，因为它可以被用来模仿锁，并有可能“阻塞”流程。</p>
<p>这里的效果与互斥锁类似，但使用场景不同。使用互斥锁时，假设共享资源的状态会被其他 goroutine 频繁的修改。而 for 语句加 CAS 操作假设的往往是共享资源的状态改变不频繁，或者总是会变成期望的那样。这是一种更加乐观或者更加宽松的做法。</p>
<h2 id="变量的写已经是原子操作了读还需要吗">变量的写已经是原子操作了，读还需要吗</h2>
<p>是需要的，参照读写锁的读写互斥。读操作还没有完成时，写操作把值修改了，那面读到的值必然是错的。这显然破坏了数据的完整性。所以，一旦决定了要对共享资源进行保护，就要做到完全保护。不完全的保护和不保护基本没区别。</p>
<p>由于原子操作函数只支持非常有限的数据类型，所以在很多应用场景下互斥锁往往是更加合适的。如果是只涉及并发的读写单一整数类型的值，或者多个互不相关的整数类型值时，就不要在考虑互斥锁了。</p>
<p>因为原子操作函数的执行速度比互斥锁快得多。而且使用简单，不涉及临界区的选择以及死锁问题。</p>
<h2 id="怎样用好-syncatomicvalue">怎样用好 sync/atomic.Value</h2>
<p>为了扩大原子操作的适用范围，Go 语言在 1.4 版本发布的时候向 sync/atomic 包中添加了一个新的类型 Value。此类型的值相当于一个容器，可以被用来原子的存储和加载任意的值。</p>
<p>atomic.Value 类型是开箱即用的，我们声明一个该类型的值之后就可以直接使用了。这个类型只有两个指针方法 Store 和 Load。</p>
<p>一旦我们使用 atomic.Value 类型来存储值，那面它就不应该再被复制了。因为该类型是结构类型是属于值类型的，复制该类型的值会产生一个完全分离的新值。这个新值和旧值完全没有关系，怎么改都不会影响旧值。</p>
<h3 id="不能用原子值存储-nil">不能用原子值存储 nil</h3>
<p>我们不能把 nil 作为参数值传入原子值的 Store 方法，否则就会引发一个 panic。</p>
<p>注意，如果有一个接口类型的变量，它的动态值是 nil，但动态类型却不是 nil，那么它的值就不等于 nil。这样一个变量的值是可以被存入原子值的。</p>
<h3 id="我们向原子值存储的第一个值决定了它今后能且只能存储哪一个类型的值">我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值</h3>
<p>例如，我第一次向一个原子值存储了一个 string 类型的值，那我在后面就只能用该原子值来存储字符串了。如果我又想用它存储结构体，那么在调用它的 Store 方法的时候就会引发一个 panic。这个 panic 会告诉我，这次存储的值的类型与之前的不一致。</p>
<p>原子值内部是依据被存储值的实际类型来做判断的，即使是实现了同一个接口的不同类型，它们的值也不能被先后存储到同一个原子值中。</p>
<p>我们无法通过某个方法获知一个原子值是否已经被真正使用，并且，也没有办法通过常规的途径得到一个原子值可以存储值的实际类型。这使得我们误用原子值的可能性大大增加，尤其是在多个地方使用同一个原子值的时候。</p>
<h3 id="使用建议">使用建议</h3>
<ol>
<li>不要把内部使用的原子值暴露给外界。比如，声明一个全局的原子变量并不是一个正确的做法。这个变量的访问权限最起码也应该是包级私有的。</li>
<li>如果不得不让包外，或模块外的代码使用你的原子值，那么可以声明一个包级私有的原子变量，然后再通过一个或多个公开的函数，让外界间接地使用到它。注意，这种情况下不要把原子值传递到外界，不论是传递原子值本身还是它的指针值。</li>
<li>如果通过某个函数可以向内部的原子值存储值的话，那么就应该在这个函数中先判断被存储值类型的合法性。若不合法，则应该直接返回对应的错误值，从而避免 panic 的发生。</li>
<li>如果可能的话，我们可以把原子值封装到一个数据类型中，比如一个结构体类型。这样，我们既可以通过该类型的方法更加安全地存储值，又可以在该类型中包含可存储值的合法类型信息。</li>
</ol>
<p>尽量不要向原子值中存储引用类型的值。因为这很容易造成安全漏洞。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">box6</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span>
<span class="nx">v6</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">box6</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">v6</span><span class="p">)</span>
<span class="nx">v6</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">4</span> <span class="c1">// 注意，此处的操作不是并发安全的！
</span></code></pre></div><p>把一个 []int 类型的切片值 v6, 存入了原子值 box6。注意，切片类型属于引用类型。所以，在外面改动这个切片值，就等于修改了 box6 中存储的那个值。这相当于绕过了原子值而进行了非并发安全的操作。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">store</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">v</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">replica</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
 <span class="nb">copy</span><span class="p">(</span><span class="nx">replica</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
 <span class="nx">box6</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">replica</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">store</span><span class="p">(</span><span class="nx">v6</span><span class="p">)</span>
<span class="nx">v6</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">5</span> <span class="c1">// 此处的操作是安全的。
</span></code></pre></div><p>应该先为切片值 v6 创建了一个完全的副本。这个副本涉及的数据已经与原值毫不相干了。然后，我再把这个副本存入 box6。如此一来，无论我再对 v6 的值做怎样的修改，都不会破坏 box6 提供的安全保护。</p>
]]></content>
		</item>
		
		<item>
			<title>原子操作 sync/atomic</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_sync_atomic/</link>
			<pubDate>Fri, 25 Dec 2020 12:28:41 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_sync_atomic/</guid>
			<description>原子性执行和原子操作 对于一个 Go 程序来说，Go 语言运行时系统中的调度器会恰当的安排其中所有的 goroutine 的运行。但是在同一时刻，只可能有少数的 G 真正处于</description>
			<content type="html"><![CDATA[<h2 id="原子性执行和原子操作">原子性执行和原子操作</h2>
<p>对于一个 Go 程序来说，Go 语言运行时系统中的调度器会恰当的安排其中所有的 goroutine 的运行。但是在同一时刻，只可能有少数的 G 真正处于运行状态，这个数量只会与 M（系统级线程）的数量一致，而不会随着 G 的增多而增长。</p>
<p>为了公平起见，调度器总会频繁的换上或换下这些 G。换上是说让一个 G 由非运行状态转为运行状态，并促使其中的代码在某个 CPU 上执行。换下则相反，让一个 G 中的代码终端执行，并由运行状态转为非原型状态。</p>
<p>这个终端的时机有很多，任何两条语句执行的间隙，甚至某条语句执行的过程中都是可以的。即使这些语句在临界区也是如此。所以，互斥锁虽然能保证临界区的代码串行执行，但却不能保证这些代码的原子性执行。</p>
<p>能够保证原子性执行的只有原子操作（atomic operation）。原子操作在运行过程中是不允许终端的。在底层，这会由 CPU 提供芯片级别的支持，所以绝对有效。即使在拥有多 CPU 核心或者多 CPU 的计算机系统中，原子操作的保证也是不可撼动的。</p>
<p>这使得原子操作可以完全的消除竞态条件，并能够觉得的保证并发安全性。并且，它的执行速度要比其他同步工具快的多，通常会高出好几个数量级。</p>
<p>它的缺点也是明显的。具体的说就是因为原子操作不能被中断，所以它需要足够简单并且快速。如果原子操作迟迟不能完成，而且又不会被中断，那面将会给计算机执行指令的效率带来巨大的影响。因此，操作系统层面只针对二进制位或整数的原子操作提供支持。</p>
<p>Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代码包 sync/atomic 中。</p>
<h2 id="syncatomic-包中提供的原子操作以及可操作的数据类型">sync/atomic 包中提供的原子操作以及可操作的数据类型</h2>
<p>sync/atomic 包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、存储（store）和交换（swap）。</p>
<p>这些函数针对的数据类型并不多，对这些类型中的每一个，sync/atomic 包都会有一套函数给予支持。数据类型有：int32、int64、uint32、uint64、uintptr 以及 unsafe 包中的 Pointer。不过针对 unsafe.Pointer 类型并没有提供加法原子操作的函数。此外该包还提供了一个名为 Value 的类型，可以被用来存储任意类型的值。</p>
<h3 id="原子操作函数的第一个参数要求传指针">原子操作函数的第一个参数要求传指针</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AddInt32 atomically adds delta to *addr and returns the new value.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddInt32</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">int32</span><span class="p">,</span> <span class="nx">delta</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">(</span><span class="nx">new</span> <span class="kt">int32</span><span class="p">)</span>

<span class="c1">// CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">int32</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">(</span><span class="nx">swapped</span> <span class="kt">bool</span><span class="p">)</span>

<span class="c1">// LoadInt32 atomically loads *addr.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">LoadInt32</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">int32</span><span class="p">)</span> <span class="p">(</span><span class="nx">val</span> <span class="kt">int32</span><span class="p">)</span>

<span class="c1">// StoreInt32 atomically stores val into *addr.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">StoreInt32</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">int32</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int32</span><span class="p">)</span>

<span class="c1">// SwapInt32 atomically stores new into *addr and returns the previous *addr value.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">SwapInt32</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">int32</span><span class="p">,</span> <span class="nx">new</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">(</span><span class="nx">old</span> <span class="kt">int32</span><span class="p">)</span>
</code></pre></div><p>原子操作函数需要的是被操作值的指针，而不是这个值本身。被传入函数的参数值都会被复制，像这种基本类型的值一旦传入函数，就已经与函数外面那个值毫无关系了。</p>
<p>unsafe.Pointer 类型虽然本身就是指针类型，但是原子函数要操作的是指针值，而不是它指向的那个值，所以需要的仍然是指向这个指针值的指针。</p>
<p>只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。然后才能通过底层的指令，准确的操作这个内存地址上的数据。</p>
<h3 id="原子加法函数做原子减法">原子加法函数做原子减法</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AddInt32 atomically adds delta to *addr and returns the new value.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddInt32</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">int32</span><span class="p">,</span> <span class="nx">delta</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">(</span><span class="nx">new</span> <span class="kt">int32</span><span class="p">)</span>

<span class="c1">// AddUint32 atomically adds delta to *addr and returns the new value.
</span><span class="c1">// To subtract a signed positive constant value c from x, do AddUint32(&amp;x, ^uint32(c-1)).
</span><span class="c1">// In particular, to decrement x, do AddUint32(&amp;x, ^uint32(0)).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddUint32</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">uint32</span><span class="p">,</span> <span class="nx">delta</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">(</span><span class="nx">new</span> <span class="kt">uint32</span><span class="p">)</span>

<span class="c1">// AddInt64 atomically adds delta to *addr and returns the new value.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddInt64</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">int64</span><span class="p">,</span> <span class="nx">delta</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="nx">new</span> <span class="kt">int64</span><span class="p">)</span>

<span class="c1">// AddUint64 atomically adds delta to *addr and returns the new value.
</span><span class="c1">// To subtract a signed positive constant value c from x, do AddUint64(&amp;x, ^uint64(c-1)).
</span><span class="c1">// In particular, to decrement x, do AddUint64(&amp;x, ^uint64(0)).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddUint64</span><span class="p">(</span><span class="nx">addr</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">,</span> <span class="nx">delta</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">new</span> <span class="kt">uint64</span><span class="p">)</span>
</code></pre></div><p>atomic.AddInt32 和 atomic.AddInt64 函数的第二个参数代表差量，是有符号的数据类型，如果需要做原子减法，把这个差量设置为负整数就可以了。</p>
<p>atomic.AddUint32 和 atomic.AddUint64 函数做原子减法就不能这么直接。 因为他们的第二个参数都是无符号的，这里需要转换下。</p>
<p>比如想对 uint32 类型的被操作值 18 做原子减法，差量是 -3，那么可以先把差量转换为有符号的 int32 类型的值，然后再把该值的类型转换为 uint32，即：<code>uint32(int32(-3))</code>。</p>
<p>不过要注意，直接这样写会使 Go 语言的编译器报错，它会告诉你：“常量 -3 不在 uint32 类型可表示的范围内”，换句话说，这样做会让表达式的结果值溢出。</p>
<p>不过，如果我们先把 int32(-3) 的结果值赋给变量 delta，再把 delta 的值转换为 uint32 类型的值，就可以绕过编译器的检查并得到正确的结果了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">num</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>
<span class="nx">delta</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">num</span><span class="p">,</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">delta</span><span class="p">))</span>
</code></pre></div><p>还有一种方式更直接：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="p">^</span><span class="nb">uint32</span><span class="p">(</span><span class="o">-</span><span class="nx">N</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div><p>其中 N 代表由负整数表示的差量。就是说，我们先把差量的绝对值减去 1，然后再把这个无类型的结果常量转为 uint32 类型的值，最后在这个值上做按位异或操作就可以获得最终的参数值了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">num</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>
<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">num</span><span class="p">,</span> <span class="p">^</span><span class="nb">uint32</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div><p>简单来说，此表达式的结果值的补码，与使用前一种方法得到的值的补码相同，所以这两种方式是等价的。我们都知道，整数在计算机中是以补码的形式存在的，所以在这里，结果值的补码相同就意味着表达式的等价。</p>
]]></content>
		</item>
		
		<item>
			<title>条件变量 sync.Cond 2</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_sync_cond2/</link>
			<pubDate>Thu, 24 Dec 2020 15:04:15 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_sync_cond2/</guid>
			<description>条件变量的 Wait方法做了什么 条件变量的 Wait 方法主要做了四件事： 把调用它的 goroutine 加入到当前条件变量的通知队列中。 解锁当前条件变量基于的互斥锁。 让当</description>
			<content type="html"><![CDATA[<h2 id="条件变量的-wait方法做了什么">条件变量的 Wait方法做了什么</h2>
<p>条件变量的 Wait 方法主要做了四件事：</p>
<ul>
<li>把调用它的 goroutine 加入到当前条件变量的通知队列中。</li>
<li>解锁当前条件变量基于的互斥锁。</li>
<li>让当前的 goroutine 处于等待状态，等到通知到来时再决定是否要唤醒它。这时，goroutine 会阻塞在调用 Wait 方法的那行代码上。</li>
<li>如果通知到来并决定唤醒 goroutine，那面唤醒它之后重新锁定当前条件变量基于的互斥锁。当前的 goroutine 就可以继续执行后面的代码了。</li>
</ul>
<p>条件变量的 Wait 方法在阻塞当前 goroutine 之前，会解锁它基于的互斥锁，所以在调用 Wait 方法之前，我们必须先锁定那个互斥锁，否则调用 Wait 方法时就会引发一个不可恢复的 panic。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Wait atomically unlocks c.L and suspends execution
</span><span class="c1">// of the calling goroutine. After later resuming execution,
</span><span class="c1">// Wait locks c.L before returning. Unlike in other systems,
</span><span class="c1">// Wait cannot return unless awoken by Broadcast or Signal.
</span><span class="c1">//
</span><span class="c1">// Because c.L is not locked when Wait first resumes, the caller
</span><span class="c1">// typically cannot assume that the condition is true when
</span><span class="c1">// Wait returns. Instead, the caller should Wait in a loop:
</span><span class="c1">//
</span><span class="c1">//    c.L.Lock()
</span><span class="c1">//    for !condition() {
</span><span class="c1">//        c.Wait()
</span><span class="c1">//    }
</span><span class="c1">//    ... make use of condition ...
</span><span class="c1">//    c.L.Unlock()
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">checker</span><span class="p">.</span><span class="nf">check</span><span class="p">()</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nf">runtime_notifyListAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">notify</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nf">runtime_notifyListWait</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">notify</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>所以说，如果条件变量的 Wait 不先解锁互斥锁的话，只会造成两种后果：不是当前程序因 panic 而崩溃，就是相关的 goroutine 全面阻塞。</p>
<h2 id="为什么要用-for-而不是-if-来包裹-wait-方法">为什么要用 for 而不是 if 来包裹 Wait 方法</h2>
<p>很显然，if 语句只会对共享资源的状态检查一次，而 for 语句可以多次检查。如果一个 goroutine 因收到通知而被唤醒，却发现共享资源的状态依然不符合它的要求，那面就应该再次调用 Wait 方法继续等待下次通知。</p>
<p>有几种场景可能发生这样的情况：</p>
<ol>
<li>有多个 goroutine 在等待共享资源的同一种状态。虽然有多个 G 同时等待，但每次只能成功一个。因为条件变量的 Wait 方法会在当前的 G 醒来后重新锁定互斥锁。那别的 G 进入临界区后发现状态依然不是它们想要的，于是只能继续等待。</li>
<li>共享资源的状态不是两个而是多个。这种情况下，由于状态在每次改变后的结果只可能有一个，所以，在设计合理的前提下，单一的结果一定不可能满足所有 goroutine 的条件。那些未被满足的 G 显然还需要继续等待和检查。</li>
<li>共享资源状态有两个，并且每种状态都只有一个 G 在关注。在一些多 CPU 核心的计算机系统中，即使没收到条件变量的通知，调用 Wait 方法的 G 也是有可能被唤醒的。这是由计算机硬件层面决定的，即使操作系统本身提供的条件变量也会如此。</li>
</ol>
<h2 id="条件变量的-signal-和-broadcast-方法有什么区别">条件变量的 Signal 和 Broadcast 方法有什么区别</h2>
<p>条件变量的 Signal 和 Broadcast 方法都是用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的 G，而后者的通知会唤醒所有因此而等待的 G。</p>
<p>条件变量的 Wait 方法总会把当前的 G 添加到通知队列的队尾，而它的 Signal 方法总会通知队列的队首开始查找可被唤醒的 G。所以 Signal 唤醒的一般都是最早等待的那个。</p>
<p>此外，与 Wait 方法不同，条件变量的 Signal 和 Broadcast 方法并不需要在互斥锁的保护下执行。我们最好在解锁条件变量基于的那个互斥锁之后再去调用它的这两个方法。这更有利于程序运行的效率。</p>
<p>最后，条件变量的通知具有即时性。就是说发送通知的时候没有 G 因此而等待时，通知就会被直接丢弃。在这之后开始等待的 G 只能被后续通知唤醒。</p>
]]></content>
		</item>
		
		<item>
			<title>条件变量 sync.Cond</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_sync_cond/</link>
			<pubDate>Thu, 24 Dec 2020 08:58:23 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_sync_cond/</guid>
			<description>条件变量与互斥锁 条件变量是基于互斥锁的，它必须有互斥锁的支撑才能发挥作用。 条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共</description>
			<content type="html"><![CDATA[<h2 id="条件变量与互斥锁">条件变量与互斥锁</h2>
<p>条件变量是基于互斥锁的，它必须有互斥锁的支撑才能发挥作用。</p>
<p>条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。</p>
<p>比如，我们两个人在共同执行一项秘密任务，这需要在不直接联系和见面的前提下进行。我需要向一个信箱里放置情报，你需要从这个信箱里获取情报。这个信箱就相当于一个共享资源，而我们就分别是进行写操作和读操作的线程。</p>
<p>如果我在放置情报的时候发现信箱里还有未被取走的情报，那就不再放置并且先返回。另一面，如果你在获取情报的时候发现信箱里没有情报，也只能先回去了。这就相当于写操作和读操作线程阻塞。</p>
<p>虽然我们俩都有信箱的钥匙，但同一时刻只能有一个人插入钥匙打开信箱，这就是锁的作用了。更何况我们两个人不能直接见面，所以这个信箱本身可以视为一个临界区。</p>
<p>尽管没有协调好，咱们俩仍然要想办法完成任务。所以，如果信箱里有情报，而你却一直没取走，那我就需要每隔一段时间带着新情报去检查一次，若发现信箱空了，我要及时的把新情报放进去。</p>
<p>另一面，如果信箱里一直没有情报，你也要每隔一段时间去查看，一旦有了情报要及时取走。这么做是可以的，但是很危险，容易被敌人发现。</p>
<p>后来，我们又想了一个计策，各自雇了一个不起眼的小孩儿。如果早上七点有个戴红色帽子的小孩儿从你家楼下路过，那面就意味着信箱里有了新的情报。如果上午九点有个戴蓝色帽子的小孩儿从我家楼下路过，那说明你已经从信箱里取走了情报。</p>
<p>这样，执行任务的隐蔽性高多了，并且效率的提升非常显著。这两个戴不同颜色帽子的小孩儿就相当于条件变量，在共享资源的状态发生变化时，起到了通知的作用。</p>
<p>条件变量在这里最大的优势就是效率方面的提升。当共享资源的状态不满足条件时，想操作它的线程再也不用循环往复的做检查了，只要等待通知就好了。</p>
<h2 id="条件变量怎样配合互斥锁">条件变量怎样配合互斥锁</h2>
<p>条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。</p>
<p>条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。</p>
<p>我们再利用条件变量等待通知的时候，需要在它基于的那个互斥锁保护下进行。而在进行单发或者广播通知的时候，需要在对应的互斥锁解锁之后再做操作。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//信箱，0表示空，1表示非空
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">mailBox</span> <span class="kt">uint8</span>
	<span class="c1">//互斥锁
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">lock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
	<span class="c1">//发送条件
</span><span class="c1"></span>	<span class="nx">sendCond</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//接收条件
</span><span class="c1"></span>	<span class="nx">recvCond</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="nx">lock</span><span class="p">.</span><span class="nf">RLocker</span><span class="p">())</span>

	<span class="c1">//信号通道
</span><span class="c1"></span>	<span class="nx">sign</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">max</span> <span class="o">:=</span> <span class="mi">5</span>

	<span class="c1">//发送方
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">max</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">sign</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="p">}()</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">max</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Nanosecond</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span>
			<span class="c1">//加写锁，我要开始放置信箱了
</span><span class="c1"></span>			<span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="c1">//查看信箱是否空，空就放置新消息，非空就等待
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mailBox</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">sendCond</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;发送方 [%d]:邮箱是空的.&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="c1">//放置消息了，信箱状态设置非空
</span><span class="c1"></span>			<span class="nx">mailBox</span> <span class="p">=</span> <span class="mi">1</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;发送方 [%d]: 我放置消息了.&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="c1">//解锁，释放资源
</span><span class="c1"></span>			<span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="c1">//通知接收方
</span><span class="c1"></span>			<span class="nx">recvCond</span><span class="p">.</span><span class="nf">Signal</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}(</span><span class="nx">max</span><span class="p">)</span>

	<span class="c1">//接收方
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">max</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">sign</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="p">}()</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">max</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Nanosecond</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span>
			<span class="c1">//加读锁
</span><span class="c1"></span>			<span class="nx">lock</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
			<span class="c1">//查看信箱是否有消息，没有则等待，有则取走
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">mailBox</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">recvCond</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;接收方 [%d]: 邮箱里有消息.&#34;</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
			<span class="c1">//取走消息
</span><span class="c1"></span>			<span class="nx">mailBox</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;接收方 [%d]: 我取走消息了.&#34;</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
			<span class="c1">//解读锁
</span><span class="c1"></span>			<span class="nx">lock</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
			<span class="c1">//通知发送方
</span><span class="c1"></span>			<span class="nx">sendCond</span><span class="p">.</span><span class="nf">Signal</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}(</span><span class="nx">max</span><span class="p">)</span>

	<span class="o">&lt;-</span><span class="nx">sign</span>
	<span class="c1">//&lt;-sign
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>变量 mailbox 代表信箱，是 uint8 类型的。若它的值是 0 则表示信箱中没有情报，当它的值是 1 时，说明信箱中有情报。lock 是一个读写锁类型的变量，可以视为信箱上的那把锁。</p>
<p>基于这把锁还有两个代表条件变量的变量：sendCond 和 reveCond。都是 *sync.Cond 类型的，同时也都是由 sync.NewCond 函数来初始化的。</p>
<p>与 互斥锁和读写互斥锁不同，sync.Cond类型并不能开箱即用，我们只能利用 sync.NewCond 函数创建它的指针值。这个函数需要一个 sync.Locker 类型的参数。这里的参数值是不可或缺的，它会参与到条件变量的方法实现中。</p>
<p>sync.Locker 其实是一个接口，在它的声明中只包含了两个方法定义，即：Lock 和 Unlock。互斥锁和读写互斥锁都拥有这两个方法，只不过它们都是指针方法。所以说，这两个类型的指针类型才是 sync.Locker 接口的实现类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A Locker represents an object that can be locked and unlocked.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Locker</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Lock</span><span class="p">()</span>
	<span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>我们在为 sendCond 变量做初始化的时候，把基于 lock 变量的指针值传给了 sync.NewCond 函数。lock 变量的 Lock 方法和 Unlock 方法分别用于对其中写锁的锁定和解锁，它们与 sendCond 变量的含义是对应的。sendCond 是专门为放置情报而准备的条件变量，向信箱里放置情报，可以被视为对共享资源的写操作。</p>
<p>相应的，recvCond 变量代表的是专门为获取情报而准备的条件变量。 虽然获取情报也会涉及对信箱状态的改变，但是好在做这件事的人只会有你一个，而且我们也需要借此了解一下，条件变量与读写锁中的读锁的联用方式。所以，在这里，我们暂且把获取情报看做是对共享资源的读操作。</p>
<p>因此，为了初始化 recvCond 这个条件变量，我们需要的是 lock 变量中的读锁，并且还需要是 sync.Locker 类型的。可是，lock 变量中用于对读锁进行锁定和解锁的方法却是 RLock 和 RUnlock，它们与 sync.Locker 接口中定义的方法并不匹配。</p>
<p>好在 sync.RWMutex 类型的 RLocker 方法可以实现这一需求。我们只要在调用 sync.NewCond 函数时，传入调用表达式 lock.RLocker() 的结果值，就可以使该函数返回符合要求的条件变量了。</p>
<p>为什么说通过 lock.RLocker() 得来的值就是 lock 变量中的读锁呢？实际上，这个值所拥有的 Lock 方法和 Unlock 方法，在其内部会分别调用 lock 变量的 RLock 方法和 RUnlock 方法。也就是说，前两个方法仅仅是后两个方法的代理而已。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// RLocker returns a Locker interface that implements
</span><span class="c1">// the Lock and Unlock methods by calling rw.RLock and rw.RUnlock.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">RWMutex</span><span class="p">)</span> <span class="nf">RLocker</span><span class="p">()</span> <span class="nx">Locker</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">rlocker</span><span class="p">)(</span><span class="nx">rw</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">rlocker</span> <span class="nx">RWMutex</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">rlocker</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span>   <span class="p">{</span> <span class="p">(</span><span class="o">*</span><span class="nx">RWMutex</span><span class="p">)(</span><span class="nx">r</span><span class="p">).</span><span class="nf">RLock</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">rlocker</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{</span> <span class="p">(</span><span class="o">*</span><span class="nx">RWMutex</span><span class="p">)(</span><span class="nx">r</span><span class="p">).</span><span class="nf">RUnlock</span><span class="p">()</span> <span class="p">}</span>
</code></pre></div><p>我们现在有四个变量。一个是代表信箱的 mailbox，一个是代表信箱上的锁的 lock。还有两个是，代表了蓝帽子小孩儿的 sendCond，以及代表了红帽子小孩儿的 recvCond。</p>
<p><p class="md__image">
  <img src=".././image/3619456ade9d45a4d9c0fbd22bb6fd5d.png"
    alt=""  />
</p>
</p>
<p>我现在是一个 goroutine，想要适时的向信箱里放置情报并通知你，那么肯定要先调用 lock 变量的 Lock 方法。这意味着持有信箱上的锁，并且有打开信箱的权利，并不是锁上这个信箱。</p>
<p>然后我要检查 mailbox 变量的值是不是 1，也就是信箱里是不是存在情报，如果还有，那么我就回家等蓝帽子小孩儿了，也就是 sendCond.Wait 了。如果信箱里没有情报，那么我就把新情报放进去，关上信箱、释放锁，然后离开。</p>
<p>离开之后就让红帽子小孩儿去你家楼下路过，也就是及时通知你，信箱里有新情报了。而你要做的和我在流程上基本一致。只不过操作对象不同。</p>
]]></content>
		</item>
		
		<item>
			<title>sync.Mutex与sync.RWMutex</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_sync_mutex/</link>
			<pubDate>Wed, 23 Dec 2020 15:58:04 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_sync_mutex/</guid>
			<description>静态条件、临界区和同步工具 相比于 Go 语言宣扬的 用通讯的方式共享数据，通过共享数据的方式来传递信息和协调线程运行的做法其实更加主流，毕竟大多数的</description>
			<content type="html"><![CDATA[<h2 id="静态条件临界区和同步工具">静态条件、临界区和同步工具</h2>
<p>相比于 Go 语言宣扬的 用通讯的方式共享数据，通过共享数据的方式来传递信息和协调线程运行的做法其实更加主流，毕竟大多数的现代编程语言都是用后一种方式作为并发编程的解决方案的。</p>
<p>一旦数据被多个线程共享，那面就很可能会产生争用和冲突的情况。这种情况也被称为竞态条件（race condition），这往往会破坏共享数据的一致性。</p>
<p>共享数据的一致性代表着某种约定，即：多个线程对共享数据的操作总是可以达到它们各自预期的效果。如果这个一致性得不到保证，那面将会影响到一些线程中代码和流程的正确执行，甚至会造成某种不可预知的错误。这种错误一般很难发现和定位，排查起来的成本也是非常高的，所以一定要尽量避免。</p>
<p>当同时有多个线程向同一个缓冲区写入数据块时，如果没有一个机制去协调这些线程的写入操作的话，那面被写入的数据库就很可能出现错乱。</p>
<p>还记得曾经在一家第三方支付的公司时，每次有人要用打印机前都要大声问有没有人在用，有一次我直接打印了，结果和别人打印的冲突了，一张纸上有我的东西也有另一个同事打印的东西，最后都用不了。当然这是举个例子，在编程来说就是当线程 A 还没有写完一个数据块时，线程 B 就开始写入另外一个数据块了。</p>
<p>显然，这两个数据块中的数据会被混在一起，并且已经很难分清了。因此，这种情况下，我们需要采取一些措施来协调它们对缓冲区的修改。这通常会涉及到同步。</p>
<p>概括来讲，同步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。</p>
<p>由于这样的数据块和代码块的背后都隐含着一种或多种资源（如：存储资源、计算资源、I/O资源、网络资源等），所以我们可以把它们看作是共享资源，或者是共享资源的代表。我们所说的同步其实就是在控制多个线程对共享资源的访问。</p>
<p>一个线程在想要访问某一个共享资源时，需要先申请对该资源的访问权限，并且只有在申请成功后才能真正开始访问。当线程对共享资源的访问结束时，必须归还对该资源的访问权限，再次访问时需要重新申请。</p>
<p>我们可以把访问权限想象成一块令牌，线程一旦拿到了令牌，就可以进入指定区域从而访问到资源。而一旦线程要离开这个区域了，就需要把令牌还回去，绝对不能把令牌带走。</p>
<p>如果针对某个共享资源的访问权限令牌只有一块，那么在同一时刻，就最多只能有一个线程进入那个区域并访问到该资源。这时，我们可以说多个并发运行的线程对这个共享资源的访问是完全串行的。只要一个代码片段需要实现对共享资源的串行化访问，就可以被视为一个临界区（critical section），也就是要访问到资源而必须进入的那个区域。</p>
<p>如前面所述，实现了数据块写入操作的代码就共同组成了一个临界区。如果针对同一个共享资源，这样的代码片段有多个，那么它们就可以被称为相关临界区。</p>
<p>它们可以是一个内含了共享数据的结构体及其方法，也可以是操作同一块共享数据的多个函数。临界区总是需要收到保护的，否则就会产生竞态条件。施加保护的重要手段之一，就是使用实现了某种同步机制的工具，也称为同步工具。</p>
<p><p class="md__image">
  <img src=".././image/73d3313640e62bb95855d40c988c2e6c.png"
    alt=""  />
</p>
</p>
<h2 id="mutex-互斥锁"><code>mutex</code> 互斥锁</h2>
<p>在 Go 语言中，可供我们选择的同步工具并不少。其中，最重要且最常用的同步工具当属互斥量（mutual exclusion，简称 mutex）。sync 包中的 Mutex 就是与其对应的类型，该类型的值可以被称为互斥量或者互斥锁。</p>
<p>一个互斥锁可以被用来保护一个临界区或者一组相关临界区。我们可以通过它来保证在同一个时刻只有一个 goroutine 处于该临界区之内。</p>
<p>为了兑现这个保证，每当有 goroutine 想进入临界区时，都需要先对它进行锁定，并且每个 goroutine 离开临界区时，都要及时的对它进行解锁。</p>
<p>锁定操作可以通过调用互斥锁的 Lock 方法实现，解锁操作可以调用互斥锁的 Unlock 方法实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">writer</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
 <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;error: %s [%d]&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</code></pre></div><p>这里的互斥锁就相当于我们之前说的访问令牌。</p>
<h2 id="使用互斥锁的注意事项">使用互斥锁的注意事项</h2>
<ul>
<li>不要重复锁定互斥锁。</li>
<li>不要忘记解锁，必要时使用 defer。</li>
<li>不要对尚未锁定或者已解锁的互斥锁解锁。</li>
<li>不要在多个函数之间传递互斥锁。</li>
</ul>
<p>首先，我们还是要把互斥锁看作是针对某一个临界区或者一组相关临界区的唯一访问令牌。虽然没有任何强制规定来限制用同一个互斥锁保护多个无关的临界区，但是这样做一定会让程序变得更复杂，并且也会明显的增加我们的心智负担。</p>
<p>要知道，对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的 goroutine 的。这个 goroutine 所执行的流程，会一直停滞在调用该互斥锁的 Lock 方法的那行代码上。直到该互斥锁的 Unlock 方法被调用，并且这里的锁定操作完成，后续的代码（临界区中的代码）才会开始执行。这也是互斥锁能够保护临界区的原因所在。</p>
<p>一旦我们把一个互斥锁同时用在了多个地方，就必然会有更多的 goroutine 争用这把锁。这不但会让我们的程序变慢，还会大大增加死锁（deadlock）的可能性。</p>
<p>所谓的死锁，指的就是当前程序中的主 goroutine，以及我们启用的那些 goroutine 都已经阻塞。这些 goroutine 可以被统称为用户级的 goroutine。这就相当于整个程序已经停滞不前了。</p>
<p>Go 语言运行时系统是不允许这种情况出现的，只要它发现所有的用户级 goroutine 都处于等待状态，就会自行抛出一个带有如下信息的 panic：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fatal</span> <span class="kt">error</span><span class="p">:</span> <span class="nx">all</span> <span class="nx">goroutines</span> <span class="nx">are</span> <span class="nx">asleep</span> <span class="o">-</span> <span class="nx">deadlock</span><span class="p">!</span>
</code></pre></div><p>这种 Go 运行时系统自行抛出的 panic 都属于致命错误，都是无法被恢复的，调用 recover 函数对它们起不到任何作用。也就是说，一旦产生死锁，程序必然崩溃。</p>
<p>因此，我们一定要尽量避免这种情况的发生。而最简单、有效的方式就是让每一个互斥锁都只保护一个临界区或一组相关临界区。在这个前提下，我们还要注意对于同一个 goroutine 而言，既不要重复锁定一个互斥锁，也不要忘记对它进行解锁。</p>
<p>一个 goroutine 对某一个互斥锁的重复锁定，就意味着它自己锁死了自己。先不说这种情况本身就是错误的，这种情况下想让其他 goroutine 来帮它解锁是非常难以保证其正确性的。</p>
<p>在一个 goroutine 执行的流程中，可能会出现诸如锁定、解锁、再锁定、再解锁的操作，如果我们忘记了中间的解锁操作，那么就一定会造成重复锁定。此外，忘记解锁还会使其他的 goroutine 无法进入到该互斥锁保护的临界区，这轻则会导致一些程序功能的失效，重则会造成死锁和程序崩溃。</p>
<p>很多时候，一个函数执行的流程并不是单一的，流程中间可能会分叉，也可能会终端。如果一个流程在锁定了某个互斥锁之后分叉了，或者有被终端的可能，那么就应该使用 defer 语句来对它进行解锁，而且这样的 defer 语句应该紧跟在锁定操作之后。这是最保险的一种做法。</p>
<p>忘记解锁导致的问题有时候是比较隐蔽的，并不会那么快就暴露出来。这也是我们需要特别关注它的原因。相比之下，解锁未锁定的互斥锁会立即引发 panic。并且与死锁导致的 panic 一样，它们是无法被恢复的。因此，我们总是应该保证对于每一个锁定操作都要有且只要一个对应的解锁操作。</p>
<p><p class="md__image">
  <img src=".././image/4f86467d09ffca6e0c02602a9cb7480d.png"
    alt=""  />
</p>
</p>
<p>Go 语言中的互斥锁是开箱即用的，一旦我们声明了个 sync.Mutex 类型的变量，就可以直接使用它了。不过要注意，该类型是一个结构体类型，属于值类型中的一种。把它传给一个函数、将它从函数中返回、把它赋值给变量、让它进入某个通道都会导致它的副本产生。</p>
<p>并且原值和它的副本，以及多个副本之间都是完全独立的，它们都是不同的互斥锁。</p>
<p>如果把一个互斥锁当做参数值传给了一个函数，那面在函数中对锁的所有操作都不会对存在于该函数之外的原锁产生任何影响。</p>
<h2 id="读写锁和互斥锁的异同">读写锁和互斥锁的异同</h2>
<p>读写锁是 读/写互斥锁的简称。在 Go 语言中，读写锁由 sync.RWMutex 类型的值代表。与 sync.Mutex 类型一样，这个类型也是开箱即用的。</p>
<p>顾名思义，读写锁是把对共享资源的读操作和写操作区别对待了。它可以对这两种操作施加不同程度的保护。相比于互斥锁，读写锁可以实现更加细腻的访问控制。</p>
<p>一个读写锁中实际上包含了两个锁，即：读锁和写锁。sync.RWMutex 类型中的 Lock 方法和 Unlock 方法分别用于对写锁进行锁定和解锁，而它的 RLock 方法和 RUnlock 方法则分别用于对读锁进行锁定和解锁。</p>
<p>另外，对于同一个读写锁来说有如下规则：</p>
<ul>
<li>在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的 goroutine。</li>
<li>在写锁已被锁定的情况下试图锁定读锁，也会阻塞当前的 goroutine。</li>
<li>在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的 goroutine。</li>
<li>在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的 goroutine。</li>
</ul>
<p>对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行。</p>
<p>当然了，只有在我们正确使用读写锁的情况下才能达到这种效果。还是那句话，我们需要让每一个锁都只保护一个临界区或者一组相关临界区，并以此尽量减少误用的可能性。我们通常把这种不能同时进行的操作称作互斥操作。</p>
<p>对写锁进行解锁，会唤醒所有因试图锁定读锁而被阻塞的 goroutine。通常会使它们都成功完成对读锁的锁定。</p>
<p>对读锁进行解锁，只会在没有其他读锁锁定的前提下，唤醒因试图锁定写锁，而被阻塞的 goroutine，最终只会有一个被唤醒的 goroutine 能够成功完成对写锁的锁定，其他的 goroutine 还要原地等待。至于是哪个 goroutine，就要看谁的等待时间最长了。</p>
<p>此外，读写锁对写操作之间的互斥其实是通过它内含的一个互斥锁实现的。也可以说 Go 语言的读写锁是互斥锁的一种扩展。</p>
<p>与互斥锁类似，解锁读写锁中未被锁定的写锁，会立即引发 panic，对于读锁也是如此，并且不能恢复。</p>
]]></content>
		</item>
		
		<item>
			<title>更多的测试手法</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_test3/</link>
			<pubDate>Tue, 22 Dec 2020 17:04:57 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_test3/</guid>
			<description>-cpu 的功能 go test 命令的标记 -cpu，它是用来设置测试执行最大 P 数量的列表的。 这里的 P 是 processor 的缩写，每个 processor 都是一个可以承载若干个 G，且能够使这些 G 适</description>
			<content type="html"><![CDATA[<h2 id="-cpu-的功能"><code>-cpu</code> 的功能</h2>
<p><code>go test</code> 命令的标记 <code>-cpu</code>，它是用来设置测试执行最大 <code>P</code> 数量的列表的。</p>
<blockquote>
<p>这里的 P 是 processor 的缩写，每个 processor 都是一个可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接并得到真正运行的中介。正是由于 P 的存在，G 和 M 才可以呈现出多对多的关系，并能够及时、灵活地进行组合和分离。这里的 G 就是 goroutine 的缩写，可以被理解为 Go 语言自己实现的用户级线程。M 即为 machine 的缩写，代表着系统级线程，或者说操作系统内核级别的线程。</p>
</blockquote>
<p><code>Go</code> 语言并发模型中的 <code>P</code>，正是 <code>goroutine</code> 的数量能够数十万计的关键。<code>P</code> 的数量意味着 <code>Go</code> 程序背后的运行时系统中，会有多少个用于承载可运行的 <code>G</code> 的队列存在。</p>
<p>每一个队列相当于一条流水线，它会源源不断的把可运行的 G 输送给空闲的 M，并使这两者对接。</p>
<p>一旦完成对接，被对接的 G 就真正运行在操作系统的内核级线程上了，每条流水线之间虽然会有联系，但都是独立运作的。</p>
<p>因此，最大 P 数量就代表着 Go 语言运行时系统同时运行 goroutine 的能力，也可以被视为其中逻辑 CPU 的最大个数。而 go test 命令的 -cpu 标记正是用于设置这个最大个数的。</p>
<p>默认情况下，最大 P 数量就等于当前计算机 CPU 核心的实际数量。我们可以通过使用 -cpu 模拟被测程序在计算能力不同的计算机中的表现。</p>
<h2 id="怎样设置--cpu-的值它会对测试流程产生怎样的影响">怎样设置 -cpu 的值，它会对测试流程产生怎样的影响</h2>
<p>标记 -cpu 的值应该是一个正整数的列表，该列表的表现形式为，以英文半角逗号分隔的多个整数字面量。如：1,2,4。</p>
<p>针对于此值中的每一个正整数，go test 命令都会先设置最大 P 数量为该数，然后在执行测试函数。</p>
<p>如果测试函数有多个，那么 go test 命令会依照此方式逐个执行。</p>
<blockquote>
<p>以1,2,4为例，go test 命令会先以 1,2,4 为最大 P 数量分别去执行第一个测试函数，之后再用同样的方式执行第二个测试函数，以此类推。</p>
</blockquote>
<p>go test 命令在进行准备工作的时候会读取 -cpu 标记的值，并把它转换为一个以 int 为元素类型的切片，我们也可以称它为逻辑 CPU 切片。</p>
<p>如果该命令发现我们并没有追加这个标记，那么就会让逻辑 CPU 切片只包含一个元素，即最大 P 数量的默认值，也就是当前计算机 CPU 的实际数量。</p>
<p>当准备执行某个测试函数的时候，go test 命令都会迭代逻辑 CPU 切片，并在每次迭代时，根据当前元素值设置最大 P 数量，然后再去执行测试函数。</p>
<p>注意，对于性能测试函数，这里可能不止执行了一次。概括来讲，go test 命令对每一次性能测试函数的执行，都是一个探索过程。它会在测试函数的执行时间上限不变的前提下，尝试找到被测程序的最大执行次数。在这个过程中，性能测试函数可能会被执行多次。</p>
<blockquote>
<p>对性能测试函数的一次探索式执行，这其中包含了对该函数的若干次执行，当然也包括了对被测程序的更多次执行。</p>
</blockquote>
<h2 id="-count-标记">-count 标记</h2>
<p>-count 标记是专门用于重复执行测试函数的。它的值必须大于或等于 0，并且默认值为 1。</p>
<p>如果我们在运行 go test 命令时追加了 -count 5，那么对于每个测试函数，命令都会在预设不同条件下分别重复执行五次。</p>
<p>如果我们把前文所述的 -cpu 标记、-count 标记，以及探索式执行联合起来看，就可以用一个公式来描述单个性能测试函数，在 go test 命令的一次运行过程中的执行次数，即：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">性能测试函数的执行次数</span> <span class="p">=</span> <span class="s">`-cpu`</span><span class="nx">标记的值中正整数的个数</span> <span class="nx">x</span> <span class="s">`-count`</span><span class="nx">标记的值</span> <span class="nx">x</span> <span class="nx">探索式执行中测试函数的实际执行次数</span>
</code></pre></div><p>对于功能测试函数来说，这个公式会更简单一些，即：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">功能测试函数的执行次数</span> <span class="p">=</span> <span class="s">`-cpu`</span><span class="nx">标记的值中正整数的个数</span> <span class="nx">x</span> <span class="s">`-count`</span><span class="nx">标记的值</span>
</code></pre></div><p><p class="md__image">
  <img src=".././image/8dc543c7ac67dca3dae3eebc53067c56.png"
    alt=""  />
</p>
</p>
<h2 id="-parallel-标记">-parallel 标记</h2>
<p>我们在运行 go test 命令的时候，可以追加标记 -parallel，该标记的作用是：设置同一个被测代码包中的功能测试函数的最大并发执行数。该标记的默认值是测试运行时的最大 P 数量（这可以通过调用表达式 runtime.GOMAXPROCS(0) 获得）。</p>
<p>对于功能测试，为了加快测试速度，命令通常会并发地测试多个被测代码包。但是，在默认情况下，对于同一个被测代码包中的多个功能测试函数，命令会串行地执行它们。除非我们在一些功能测试函数中显式地调用 t.Parallel 方法。</p>
<p>这个时候，这些包含了 t.Parallel 方法调用的功能测试函数就会被 go test 命令并发地执行，而并发执行的最大数量正是由 -parallel 标记值决定的。不过要注意，同一个功能测试函数的多次执行之间一定是串行的。</p>
<p>最后，强调一下，-parallel 标记对性能测试是无效的。当然了，对于性能测试来说，也是可以并发进行的，不过机制上会有所不同。</p>
<p>概括地讲，这涉及了 b.RunParallel 方法、b.SetParallelism 方法和 -cpu 标记的联合运用。</p>
<h2 id="性能测试函数中的计时器">性能测试函数中的计时器</h2>
<p>testing 包中的 testing.B 类型有这么几个指针方法：StartTimer、StopTimer 和 ResetTimer。这些方法都是用于操作当前的性能测试函数专属的计时器的。</p>
<p>所谓的计时器，是一个逻辑上的概念，它其实是 testing.B 类型中一些字段的统称。这些字段用于记录：当前测试函数在当次执行过程中耗费的时间、分配的堆内存的字节数以及分配次数。</p>
<p>这三个方法在开始记录、停止记录或重新记录执行时间的同时，也会对堆内存分配字节数和分配次数的记录起到相同的作用。</p>
<p>实际上，go test 命令本身就会用到这样的计时器。当准备执行某个性能测试函数的时候，命令会重置并启动该函数专属的计时器。一旦这个函数执行完毕，命令又会立即停止这个计时器。</p>
<p>如此一来，命令就能够准确地记录下测试函数执行时间了。然后，命令就会将这个时间与执行时间上限进行比较，并决定是否在改大 b.N 的值之后，再次执行测试函数。</p>
<p>显然，如果我们在测试函数中自行操作这个计时器，就一定会影响到这个探索式执行的结果。也就是说，这会让命令找到被测程序的最大执行次数有所不同。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkGetPrimes</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">StopTimer</span><span class="p">()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span> <span class="c1">// 模拟某个耗时但与被测程序关系不大的操作。
</span><span class="c1"></span>	<span class="nx">max</span> <span class="o">:=</span> <span class="mi">10000</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">StartTimer</span><span class="p">()</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nf">GetPrimes</span><span class="p">(</span><span class="nx">max</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这里先停止了当前测试函数的计时器，然后通过调用 time.Sleep 函数，模拟了一个比较耗时的额外操作，并且在给变量 max 赋值之后又启动了该计时器。</p>
<p>想象一下，我们需要耗费额外的时间去确定 max 变量的值，虽然在后面它会被传入 GetPrimes 函数，但是，针对 GetPrimes 函数本身的性能测试并不应该包含确定参数值的过程。</p>
<p>因此，我们需要把这个过程所耗费的时间，从当前测试函数的执行时间中去除掉。这样就能够避免这一过程对测试结果的不良影响了。</p>
<p>每当这个测试函数执行完毕后，go test 命令拿到的执行时间都只应该包含调用 GetPrimes 函数所耗费的那些时间。只有依据这个时间做出的后续判断，以及找到被测程序的最大执行次数才是准确的。</p>
<p>在性能测试函数中，我们可以通过对 b.StartTimer 和 b.StopTimer 方法的联合运用，再去除掉任何一段代码的执行时间。</p>
<p>相比之下，b.ResetTimer 方法的灵活性就要差一些了，它只能用于：去除在调用它之前那些代码的执行时间。不过，无论在调用它的时候，计时器是不是正在运行，它都可以起作用。</p>
]]></content>
		</item>
		
		<item>
			<title>测试的基本规则和流程 2</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_test2/</link>
			<pubDate>Tue, 22 Dec 2020 15:39:09 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_test2/</guid>
			<description>怎样解释功能测试的结果 go test gocore/gotest ok gocore/gotest 0.204s 第一行是输入的命令，表示对 gocore/gotest 代码包进行测试。下面一行是此次测试的简要结果，共有三块内容，首先是本次测试结果</description>
			<content type="html"><![CDATA[<h2 id="怎样解释功能测试的结果">怎样解释功能测试的结果</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">test</span> <span class="nx">gocore</span><span class="o">/</span><span class="nx">gotest</span>
<span class="nx">ok</span>      <span class="nx">gocore</span><span class="o">/</span><span class="nx">gotest</span>   <span class="mf">0.204</span><span class="nx">s</span>
</code></pre></div><p>第一行是输入的命令，表示对 <code>gocore/gotest</code> 代码包进行测试。下面一行是此次测试的简要结果，共有三块内容，首先是本次测试结果，<code>ok</code> 表示测试成功，也就是说没有发现不符合预期的情况。中间是被测试代码包的导入路径，最后展现的是本次测试所耗费的时间，不过当我们第二次运行这个命令时，输出的测试结果会有不同：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">test</span> <span class="nx">gocore</span><span class="o">/</span><span class="nx">gotest</span>
<span class="nx">ok</span>      <span class="nx">gocore</span><span class="o">/</span><span class="nf">gotest</span>   <span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
</code></pre></div><p>可以看到，结果最右边的不再是测试耗时，而是 <code>(cached)</code>。这表明，由于测试代码与被测试代码都没有任何改动，所以 <code>go test</code> 命令直接把之前换成测试成功的结果打印出来了。</p>
<p><code>go</code> 命令通常会缓存程序构建的结果，以便在将来的构建中重用。我们可以通过运行 <code>go env GOCACHE</code> 命令来查看缓存目录的路径。缓存的数据总是能够正确的反应出当时的各种源码文件、构建环境、编译器选项等真实情况。</p>
<p>一旦有任何改动，缓存数据就会失效，<code>go</code> 命令就会再次真正的执行操作。所以我们不用担心打印出的缓存数据不是实时的结果。<code>go</code> 命令会定期的删除最近未使用的缓存数据，但是，如果你想手动删除所有的缓存数据，运行一下 <code>go clean --cache</code> 命令就好了。</p>
<p>对于测试成功的结果，<code>go</code> 命令也是会缓存的。运行 <code>go clean --testcache</code> 命令将会删除所有的测试结果缓存。而这样并不会删除任何构建结果。</p>
<blockquote>
<p>设置环境变量 <code>GODEBUG</code> 的值可以稍稍的改变 <code>go</code> 命令的缓存行为。比如，设置值为 <code>gocacheverify=1</code> 将会导致 <code>go</code> 命令绕过任何的缓存数据，而真正的执行操作并重新生成所有的结果，然后再去检查新的结果与现有的缓存数据是否一致。</p>
</blockquote>
<p>我们并不需要在意缓存数据的存在，它们并不会妨碍 <code>go test</code> 命令打印正确的测试结果。</p>
<p>当我们在功能测试函数中调用 <code>t.Fail</code> 方法时，虽然当前的测试函数会继续执行下去，但是结果会显示测试失败：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">test</span> <span class="nx">gocore</span><span class="o">/</span><span class="nx">gotest</span>
<span class="o">---</span> <span class="nx">FAIL</span><span class="p">:</span> <span class="nf">TestFail</span> <span class="p">(</span><span class="mf">0.00</span><span class="nx">s</span><span class="p">)</span>
    <span class="nx">main_test</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span> <span class="nx">Failed</span><span class="p">.</span>
<span class="nx">FAIL</span>
<span class="nx">FAIL</span>    <span class="nx">gocore</span><span class="o">/</span><span class="nx">gotest</span>   <span class="mf">0.201</span><span class="nx">s</span>
</code></pre></div><p>对于失败测试的结果，<code>go test</code> 命令并不会进行缓存，这种情况下每次测试都会产生新的结果。另外，<code>go test</code> 会把失败的测试函数中的常规测试日志一并打印出来。想在测试成功时查看的话需要执行 <code>go test -v</code> 命令。</p>
<blockquote>
<p>如果想让某个测试函数在执行过程中立即失败，则可以在函数中使用 <code>t.FailNow</code> 方法。该方法执行后函数会立即终止运行，之后的代码都失去执行机会。</p>
</blockquote>
<p>如果需要在测试失败的同时打印失败测试日志，可以直接调用 <code>t.Error</code> 或者 <code>t.Errorf</code>。前者相当于 <code>t.Log</code> 和 <code>t.Fail</code> 连续调用，后者也类似。</p>
<p>还有 <code>t.Fatal</code> 和 <code>t.Fatalf</code>，它们的作用是在打印失败错误日志之后即终止当前测试函数的执行并宣告测试失败。具体的说，相当于它们最后调用了 <code>t.FailNow</code>。</p>
<h2 id="怎样解释性能测试的结果">怎样解释性能测试的结果</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">test</span> <span class="o">-</span><span class="nx">bench</span><span class="p">=.</span> <span class="o">-</span><span class="nx">run</span><span class="p">=^</span><span class="err">$</span> <span class="nx">gocore</span><span class="o">/</span><span class="nx">gotest</span><span class="o">/</span><span class="nx">xingneng</span>
<span class="nx">goos</span><span class="p">:</span> <span class="nx">windows</span>
<span class="nx">goarch</span><span class="p">:</span> <span class="nx">amd64</span>
<span class="nx">pkg</span><span class="p">:</span> <span class="nx">gocore</span><span class="o">/</span><span class="nx">gotest</span><span class="o">/</span><span class="nx">xingneng</span>
<span class="nx">BenchmarkGetPrimes</span><span class="o">-</span><span class="mi">4</span>      <span class="mi">444450</span>              <span class="mi">2390</span> <span class="nx">ns</span><span class="o">/</span><span class="nx">op</span>
<span class="nx">PASS</span>
<span class="nx">ok</span>      <span class="nx">gocore</span><span class="o">/</span><span class="nx">gotest</span><span class="o">/</span><span class="nx">xingneng</span>  <span class="mf">1.301</span><span class="nx">s</span>
</code></pre></div><p>我们运行 <code>go test</code> 命令时加了两个标记。第一个标记及其值是 <code>-bench=.</code>，只有有了这个标记，命令才会进行性能测试。该标记的值 <code>.</code>  表明需要执行任意名称的性能测试函数，当然了，函数名称还是要符合 <code>Go</code> 程序测试的基本规则的。</p>
<p>第二个标记及其值 <code>-run=^$</code> 表明需要执行哪些功能测试函数，同样以函数名称为依据的。该标记的值 <code>^$</code> 表明只执行名称为空的功能测试函数，也就是说不执行任何功能测试函数。</p>
<p>这两个标记的值都是正则表达式，如果运行 <code>go test</code> 命令的时候不加 <code>-run</code> 标记，那么会使它执行被测试代码包中所有的功能测试函数。</p>
<p>在看测试结果，重点看倒数第三行。<code>BenchmarkGetPrimes-4</code> 被称为单个性能测试的名称，它表示命令执行了性能测试函数 <code>BenchmarkGetPrimes</code>，并且当时所用的最大 <code>P</code> 数量是 4。</p>
<p>最大 <code>P</code> 数量相当于可以同时运行 <code>goroutine</code> 的逻辑 <code>CPU</code> 的最大个数。这里的逻辑 <code>CPU</code>，也可以被称为 <code>CPU</code> 核心，但它并不等同于计算机中真正的 <code>CPU</code> 核心，只是 <code>Go</code> 语言运行时系统内部的一个概念，代表着它同时运行 <code>goroutine</code> 的能力。</p>
<p>我们可以通过调用 <code>runtime.GOMAXPROCS</code> 函数改变最大 <code>P</code> 数量，也可以在运行 <code>go test</code> 命令时，加入标记 <code>-cpu</code> 来设置一个最大 <code>P</code> 数量的列表，以供命令在多次测试时使用。</p>
<p>在性能测试函数名称右边的是，<code>go test</code> 命令最后一次执行性能测试函数的时候被测函数被执行的时间次数。</p>
<p><code>go test</code> 命令在执行性能测试函数的时候会给它一个正整数，若该测试函数的唯一参数的名称为 <code>b</code>，则该正整数就由 <code>b.N</code> 代表。我们应该在测试函数中配合着编码，如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nf">GetPrimes</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们在一个会迭代 <code>b.N</code> 次的循环中调用了 <code>GetPrimes</code> 函数，并给予它参数值 1000。<code>go test</code> 命令会先尝试把 <code>b.N</code> 设置为 1，然后执行测试函数。</p>
<p>如果测试函数的执行时间没有超过上限，此上限默认为 1 秒，那么命令就会改大 <code>b.N</code> 的值，然后再次执行测试函数，如此往复，直到这个时间大于或等于上限为止。</p>
<p>当某次执行的时间大于或等于上限时，我们就说这是命令此次对该测试函数的最后一次执行。这时的 <code>b.N</code> 的值就会被包含在测试结果中，也就是上述测试结果中的 444450。</p>
<p>我们可以简称该值为执行次数，但要注意，它指的是被测函数的执行次数，而不是性能测试函数的执行次数。</p>
<p>最后再看这个执行次数的右边，<code>2390 ns/op</code> 表明单次执行 <code>GetPrimes</code> 函数的平均耗时为 2390 纳秒。这其实就是通过将最后一次执行测试函数时的执行时间，除以（被测函数的）执行次数而得出的。</p>
<p><p class="md__image">
  <img src=".././image/78d4c73a9aa9d48b59d3fd304d4b2069.png"
    alt=""  />
</p>
</p>
]]></content>
		</item>
		
		<item>
			<title>测试的基本规则和流程</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_test/</link>
			<pubDate>Tue, 22 Dec 2020 09:50:10 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_test/</guid>
			<description>Go 程序测试基础知识 单元测试，又称程序员测试。顾名思义，就是程序员们本该做的自我检查工作之一。 Go 语言的缔造者们从一开始就非常重视程序测试，并且</description>
			<content type="html"><![CDATA[<h2 id="go-程序测试基础知识"><code>Go</code> 程序测试基础知识</h2>
<p>单元测试，又称程序员测试。顾名思义，就是程序员们本该做的自我检查工作之一。</p>
<p><code>Go</code> 语言的缔造者们从一开始就非常重视程序测试，并且为 <code>Go</code> 程序的开发者们提供了丰富的 <code>API</code> 和工具。利用这些 <code>API</code> 和工具，我们可以创建测试源码文件，并且为命令源码文件和库源码文件中的程序实体编写测试用例。</p>
<p>在 <code>Go</code> 语言中，一个测试用例往往会由一个或多个测试函数来代表，大多情况下每个测试用例仅用一个测试函数就足够了。测试函数往往用于描述和保障某个程序实体的某方面功能，比如，该功能在什么情况下会因什么样的输入，产生什么样的输出，又比如，该功能会在什么情况下报错或表现异常等等。</p>
<p>我们可以为 <code>Go</code> 程序编写三类测试，即：功能测试（test）、基准测试（benchmark，也称性能测试）以及示例测试（example）。对于前两类测试，从名称上就应该可以猜到它们的用途，而示例测试严格来讲也是一种功能测试，只不过它更关注程序打印出来的内容。</p>
<p>一般情况下，一个测试源码文件只会针对于某个命令源码文件，或库源码文件做测试，所以我们总会（并且应该）把它们放在同一个代码包内。测试源码文件的名称应该以被测试源码文件的主名称为前导，并且必须以 <code>_test</code> 为后缀。比如，如果被测源码文件的名称为 <code>demo.go</code>，那么针对它的测试源码文件的名称就应该是 <code>demo_test.go</code>。</p>
<p>每个测试源码文件都必须至少包含一个测试函数。并且，从语法上来讲，每个测试源码文件中，都可以包含用来做任何一类测试的测试函数，即使把这三类测试函数都塞进去也没有问题。只要把控好测试函数的分组和数量就可以了。</p>
<p>我们可以根据这些测试函数针对的不同程序实体，把它们分成不同的逻辑组，并且利用注释以及帮助类的变量或函数来做分割。同时，我们还可以根据被测试源码文件中程序实体的先后顺序，来安排测试源码文件中测试函数的顺序。</p>
<h2 id="go-语言对测试函数的名称和签名的规定"><code>Go</code> 语言对测试函数的名称和签名的规定</h2>
<ul>
<li>对于测试功能函数来说，其名称必须以 <code>Test</code> 为前缀，并且参数列表中只应有一个 <code>*testing.T</code> 类型的参数声明。</li>
<li>对于性能测试函数来说，其名称必须以 <code>Benchmark</code> 为前缀，并且唯一参数的类型必须是 <code>*testing.B</code> 类型的。</li>
<li>对于示例测试函数来说，其名称必须以 <code>Example</code> 为前缀，但对函数的参数列表没有强制规定。</li>
</ul>
<p>只有测试源码文件的名称对了，测试函数的名称和签名也对了，当我们运行 <code>go test</code> 命令的时候，其中的测试代码才有可能被运行。</p>
<h3 id="go-test-执行的测试流程"><code>go test</code> 执行的测试流程</h3>
<p><code>go test</code> 命令在开始运行的时候，会先做一些准备工作。比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，以及判断我们给予的标记是否合法等等。</p>
<p>准备工作完成后，<code>go test</code> 命令就会针对每个被测试代码包，依次进行构建、执行包中符合要求的测试函数，清理临时文件，打印测试结果。这就是通常情况下的主要测试流程。</p>
<p>对于每个代码包，<code>go test</code> 命令会串行的执行测试流程中的每个步骤。但是，为了加快速度，它通常会并发的对多个被测代码包进行功能测试。只是在最后打印测试结果时会依照我们给定的顺序逐个进行，这会让我们感觉到它是完全串行的执行测试流程。</p>
<p>另一方面，由于并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的。更具体的说，只有在所有的构建步骤都做完之后，<code>go test</code> 命令才会真正的开始进行性能测试。</p>
<p>并且，下一个代码包性能测试的进行，总会等到上一个代码包性能测试的结果打印完成才会开始，而且性能测试函数的执行也都会是串行化的。</p>
]]></content>
		</item>
		
		<item>
			<title>Go 异常处理 2</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_panic2/</link>
			<pubDate>Mon, 21 Dec 2020 16:22:57 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_panic2/</guid>
			<description>怎样让 panic 包含一个值，应该让它包含什么值 在调用 panic 函数时，把某个值作为参数传给该函数就可以了。由于 panic 函数的唯一一个参数是空接口类型的，从语法上讲</description>
			<content type="html"><![CDATA[<h2 id="怎样让-panic-包含一个值应该让它包含什么值">怎样让 <code>panic</code> 包含一个值，应该让它包含什么值</h2>
<p>在调用 <code>panic</code> 函数时，把某个值作为参数传给该函数就可以了。由于 <code>panic</code> 函数的唯一一个参数是空接口类型的，从语法上讲，它可以接受任何类型的值。但是我们最好传入 <code>error</code> 类型的错误值，或者其他可以被有效序列化的值。这里的有效序列化指的是可以更易读的去表示形式转换。</p>
<p>对于 <code>fmt</code> 包下的各种打印函数来说，<code>error</code> 类型值的 <code>Error</code> 方法与其他类型值的 <code>String</code> 函数是等价的，它们的唯一结果都是 <code>string</code> 类型的。我们在通过占位符 <code>%s</code> 打印这些值的时候，它们的字符串表示形式分别都是这两种方法产出的。</p>
<p>一旦程序异常了，我们就一定要把异常的相关信息记录下来，这通常都是记录到程序日志里。我们在排查错误时，首先要做的就是查看和解读程序日志。而最常用也是最方便的日志记录方式，就是记录下相关值的字符串表示形式。</p>
<p>所以，如果你觉得某个值可能被记到日志里，那么就应该为它关联 <code>String</code> 方法。如果这个值是 <code>error</code> 类型的，那么让它的 <code>Error</code> 方法返回你为它定制的字符串表示形式就可以了。</p>
<p>对于 <code>fmt.Sprintf</code>，以及 <code>fmt.Fprintf</code> 这类可以格式化输出参数的函数，它们本身就可以被用来输出值的某种表示形式。不过，它们在功能上肯定不如我们自己定义的 <code>String</code> 方法或者 <code>Error</code> 方法。因此，为不同的数据类型分别编写这两种方法总是首选。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Enter function main.&#34;</span><span class="p">)</span>
	<span class="nf">caller</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Exit function main.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">caller</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Enter function caller.&#34;</span><span class="p">)</span>
	<span class="nb">panic</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;something wrong&#34;</span><span class="p">))</span> <span class="c1">// 正例。
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">)</span>                   <span class="c1">// 反例。
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Exit function caller.&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>同理，在程序崩溃的时候，将 <code>panic</code> 包含的那个值字符串表示形式打印出来。另外还可以施加某种保护措施，避免程序崩溃。这时，<code>panic</code> 包含的值会被取出然后打印出来或者记录到日志里。</p>
<h2 id="panic-保护措施"><code>panic</code> 保护措施</h2>
<p><code>Go</code> 语言的内建函数 <code>recover</code> 专用于恢复 <code>panic</code>，或者说平息运行时恐慌。<code>recover</code> 函数无需任何参数，并且会返回一个空接口类型的值。</p>
<p>如果用法正确，这个值实际上就是即将恢复的 <code>panic</code> 包含的值。并且，如果这个 <code>panic</code> 是因我们调用 <code>panic</code> 函数而引发的，那么该值同时也会是我们此次调用 <code>panic</code> 函数时，传入的参数副本。请注意，这里强调用法的正确。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Enter function main.&#34;</span><span class="p">)</span>
	<span class="c1">// 引发panic。
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;something wrong&#34;</span><span class="p">))</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;panic: %s\n&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Exit function main.&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在上面这个 <code>main</code> 函数里，我们先通过调用 <code>panic</code> 引发了一个 <code>panic</code>，紧接着想调用 <code>recover</code> 函数恢复这个 <code>panic</code>。可是结果依旧崩溃，这个 <code>recover</code> 函数调用并不会起到任何作用，甚至都没有机会执行。</p>
<p>因为 <code>panic</code> 一旦发生，控制权就会迅速的沿着调用栈的反方向传播。所以，在 <code>panic</code> 函数调用之后的代码，根本就没有执行的机会。</p>
<p>即使我们把 <code>recover</code> 函数提前，就是说先调用 <code>recover</code> 函数，在调用 <code>panic</code> 函数也是不行的。如果我们在调用 <code>recover</code> 时根本没发生 <code>panic</code>，那么该函数不会做任何事，只会返回一个 <code>nil</code>。</p>
<p><code>defer</code> 语句就是被用来延迟执行代码的。它将代码延迟到该语句所在函数即将执行结束的那一刻，无论结束执行的原因是什么。与 <code>go</code> 语句类似，一个 <code>defer</code> 语句总是由一个 <code>defer</code> 关键字和一个调用表达式组成。</p>
<p>这里存在一些限制，有一些调用表达式是不能出现在这里的，包括：针对 <code>Go</code> 语言内建函数的调用表达式，以及针对 <code>unsafe</code> 包中的函数调用表达式。对于 <code>go</code> 语句中的调用表达式，限制也是一样的。另外，在这里被调用的函数可以是有名称的，也可以是匿名的。我们可以把这里的函数叫做 <code>defer</code> 函数或者延迟函数。注意，被延迟执行的是 <code>defer</code> 函数，而不是 <code>defer</code> 语句。</p>
<p>无论结束执行的原因是什么，其中的 <code>defer</code> 函数都会在它即将结束执行的那一刻执行。即使导致它执行结束的原因是一个 <code>panic</code> 也会是这样。所以，我们需要联用 <code>defer</code> 语句和 <code>recover</code> 函数调用，才能够恢复一个已经发生的 <code>panic</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Enter function main.&#34;</span><span class="p">)</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Enter defer function.&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;panic: %s\n&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Exit defer function.&#34;</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="c1">// 引发panic。
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;something wrong&#34;</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Exit function main.&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在这个 <code>main</code> 函数中，我们首先编写了一条 <code>defer</code> 语句，并在 <code>defer</code> 函数中调用了 <code>recover</code> 函数。仅当调用的结果不为 <code>nil</code> 时，也就是说只有 <code>panic</code> 确实已发生时，才会打印一行以 <code>panic:</code> 为前缀的内容。</p>
<p>紧接着调用了 <code>panic</code> 函数，并传入了一个 <code>error</code> 类型值。这里注意尽量把 <code>defer</code> 语句写在函数体的开始处，因为在引发 <code>panic</code> 的语句之后的所有语句，都不会有任何机会执行。只有这样，<code>defer</code> 函数中的 <code>recover</code> 函数调用才会拦截，并恢复 <code>defer</code> 语句所属的函数及其调用的代码中所发生的 <code>panic</code>。</p>
<h2 id="当有多条-defer-时的执行顺序">当有多条 <code>defer</code> 时的执行顺序</h2>
<p>在同一个函数中，<code>defer</code> 函数调用的执行顺序与他们分别所属的 <code>defer</code> 语句的出现顺序（更严谨的说，是执行顺序）完全相反。</p>
<p>当一个函数即将结束执行时，其中的写在最下面的 <code>defer</code> 函数调用会被先执行，其次是写在它上面、与它距离最近的那个 <code>defer</code> 函数调用，以此类推，最上边的 <code>defer</code> 会最后一个执行。</p>
<p>如果函数中有一条 <code>for</code> 语句，并且这条 <code>for</code> 语句中包含了一条 <code>defer</code> 语句，那么，显然这条 <code>defer</code> 语句的执行次数就取决于 <code>for</code> 语句的迭代次数。</p>
<p>在 <code>defer</code> 语句每次执行的时候，<code>Go</code> 语言会把它携带的 <code>defer</code> 函数及其参数值另行存储到一个链表中。这个链表与该 <code>defer</code> 语句所属的函数是对应的，它是先进后出的（FILO），相当于一个栈。</p>
<p>在需要执行某个函数中的 <code>defer</code> 函数调用时，<code>Go</code> 语言会先拿到对应的链表，然后从中一个个的取出 <code>defer</code> 函数及其参数值，并逐个执行调用。这也是上述的：<code>defer</code> 函数调用与其所属的 <code>defer</code> 语句的执行顺序完全相反的原因了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;first defer&#34;</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;defer in for [%d]\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;last defer&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//last defer
</span><span class="c1">//defer in for [2]
</span><span class="c1">//defer in for [1]
</span><span class="c1">//defer in for [0]
</span><span class="c1">//first defer
</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go 异常处理</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_panic/</link>
			<pubDate>Sun, 20 Dec 2020 09:06:46 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_panic/</guid>
			<description>运行时恐慌 panic 这种程序异常叫做 panic，我们把它翻译成运行时恐慌。其中恐慌是由 panic 直译过来的，之所以加上运行时是因为这种异常只会在程序运行时的</description>
			<content type="html"><![CDATA[<h2 id="运行时恐慌-panic">运行时恐慌 <code>panic</code></h2>
<p>这种程序异常叫做 <code>panic</code>，我们把它翻译成运行时恐慌。其中恐慌是由 <code>panic</code> 直译过来的，之所以加上运行时是因为这种异常只会在程序运行时的时候抛出来。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
<span class="p">}</span>

<span class="c1">//panic: runtime error: index out of range [5] with length 5
</span><span class="c1">//
</span><span class="c1">//goroutine 1 [running]:
</span><span class="c1">//main.main()
</span><span class="c1">///Users/zhangxuesong/gowork/src/gocore/gopanic/main.go:7 +0x1b
</span><span class="c1">//exit status 2
</span></code></pre></div><p>上面这个切片只有 5 个元素，而用下标 5 取第 6 个元素肯定不对的。<code>Go</code> 运行时系统执行到这一句时会抛出 <code>panic</code>，以提示我们索引越界了。如果我们没有在程序里添加任何保护措施，程序打印出 <code>panic</code> 详细信息后就会终止运行。</p>
<p>详情中 <code>runtime error</code> 表示这是一个 <code>runtime</code> 包抛出的 <code>panic</code>。其中包含了一个 <code>runtime.Error</code> 接口类型的值。<code>runtime.Error</code> 接口内嵌了 <code>error</code> 接口，并做了一点点扩展，<code>runtime</code> 包中有不少它的实现类型。</p>
<p>详情中 <code>panic: </code> 右面的内容正是这个 <code>panic</code> 包含的 <code>runtime.Error</code> 类型值的字符串表示形式。</p>
<p>此外，<code>panic</code> 详情中一般还会包含与它引发原因有关的 <code>goroutine</code> 的代码执行信息。正如详情中的 <code>goroutine 1 [running]:</code>，它表示有一个 ID 为 1 的 <code>goroutine</code> 在此 <code>panic</code> 被引发的时候正在运行。这里的 ID 并不重要，它只是 <code>Go</code> 运行时系统内部给予的一个编号，我们在程序中是无法获取和更改的。</p>
<p><code>main.main()</code> 表示这个 <code>goroutine</code> 包装的 <code>go</code> 函数就是命令源码中的 <code>main</code> 函数，也就是说这里的 <code>goroutine</code> 正是主 <code>goroutine</code>。下面一行指出这个 <code>goroutine</code> 中的哪一行代码在此 <code>panic</code> 被引发时正在执行。这包含了此行代码所属的源码文件中的行数和文件所在的绝对路径。最后的 <code>+0x1b</code> 代表此行代码相对于其所属函数的入口程序计数偏移量。一般情况下用处不大。</p>
<p>最后，<code>exit status 2</code> 表示这个程序是以退出状态码 2 结束运行的。在大多数操作系统中，只要退出状态码不为 0，都意味着程序运行的非正常结束。在 <code>Go</code> 语言中，因 <code>panic</code> 导致程序结束运行的退出状态码一般都会是 2。</p>
<h2 id="从-panic-被引发到程序终止的过程">从 <code>panic</code> 被引发到程序终止的过程</h2>
<p>某个函数中的某行代码有意或无意的引发了一个 <code>panic</code>。这时，初始的 <code>panic</code> 详情会被建立起来，并且该程序的控制权会从此行代码转移至调用其所属函数的那行代码上，也就是调用栈的上一级。</p>
<p>这也意味着，此行代码所属的函数的执行随即终止。紧接着，控制权并不会在此有片刻停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一级的沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里。</p>
<p>这里的最外层函数指的是 <code>go</code> 函数，对于主 <code>goroutine</code> 来说就是 <code>main</code> 函数。但是控制权也不会停留在那里，而是被 <code>Go</code> 运行时系统回收。</p>
<p>随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡和消失。与此同时，在这个控制传播过程中，<code>panic</code> 详情会主键的积累和完善，并会在程序终止之前被打印出来。</p>
<p><code>panic</code> 可能是我们在无意间引发的，如前文所属的索引越界。这类 <code>panic</code> 是真正的、在我们意料之外的程序异常。除此之外，我们还可以有意的引发 <code>panic</code>。</p>
<p><code>Go</code> 语言内建函数 <code>panic</code> 是专门用于引发 <code>panic</code> 的。该函数使程序开发者可以在程序运行期间报告异常。注意，这与函数返回错误值的意义是完全不同的。当我们的函数返回一个非 <code>nil</code> 的错误值时，函数的调用放有权选择不处理，并且不处理的结果往往是不致命的。</p>
<p>这里的不致命是说不至于使程序无法提供任何功能或者直接崩溃并终止运行。</p>
<p>当一个 <code>panic</code> 发生时，如果我们不加任何保护措施，那么导致的后果可能是程序崩溃，这显然是致命的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Enter function main.&#34;</span><span class="p">)</span>
	<span class="nf">caller1</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Exit function main.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">caller1</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Enter function caller1.&#34;</span><span class="p">)</span>
	<span class="nf">caller2</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Exit function caller1.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">caller2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Enter function caller2.&#34;</span><span class="p">)</span>
	<span class="nx">s1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
	<span class="nx">e5</span> <span class="o">:=</span> <span class="nx">s1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">e5</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Exit function caller2.&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>提示：<code>panic</code> 详情会在控制权传播的过程中，被主键的积累和完善，并且，控制权会一级一级的沿着调用栈反方向传播至顶端。</p>
<p>因此，在针对某个 <code>goroutine</code> 的代码执行信息中，调用栈底层的信息会先出现，然后是上一级的调用信息，以此类推，最后才是此调用栈顶端的信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Enter</span> <span class="nx">function</span> <span class="nx">main</span><span class="p">.</span>
<span class="nx">Enter</span> <span class="nx">function</span> <span class="nx">caller1</span><span class="p">.</span>
<span class="nx">Enter</span> <span class="nx">function</span> <span class="nx">caller2</span><span class="p">.</span>
<span class="nx">panic</span><span class="p">:</span> <span class="nx">runtime</span> <span class="kt">error</span><span class="p">:</span> <span class="nx">index</span> <span class="nx">out</span> <span class="nx">of</span> <span class="k">range</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="nx">with</span> <span class="nx">length</span> <span class="mi">5</span>

<span class="nx">goroutine</span> <span class="mi">1</span> <span class="p">[</span><span class="nx">running</span><span class="p">]:</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">caller2</span><span class="p">()</span>
        <span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">zhangxuesong</span><span class="o">/</span><span class="nx">gowork</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">gocore</span><span class="o">/</span><span class="nx">gopanic</span><span class="o">/</span><span class="nx">main1</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span> <span class="o">+</span><span class="mh">0x85</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">caller1</span><span class="p">()</span>
        <span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">zhangxuesong</span><span class="o">/</span><span class="nx">gowork</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">gocore</span><span class="o">/</span><span class="nx">gopanic</span><span class="o">/</span><span class="nx">main1</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">15</span> <span class="o">+</span><span class="mh">0x7e</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">main</span><span class="p">()</span>
        <span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">zhangxuesong</span><span class="o">/</span><span class="nx">gowork</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">gocore</span><span class="o">/</span><span class="nx">gopanic</span><span class="o">/</span><span class="nx">main1</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">9</span> <span class="o">+</span><span class="mh">0x7e</span>
<span class="nx">exit</span> <span class="nx">status</span> <span class="mi">2</span>
</code></pre></div><p><p class="md__image">
  <img src=".././image/606ff433a6b58510f215e57792822bd7.png"
    alt=""  />
</p>
</p>
<p>深入地了解此过程，以及正确地解读 <code>panic</code> 详情应该是我们的必备技能，这在调试 <code>Go</code> 程序或者为 <code>Go</code> 程序排查错误的时候非常重要。</p>
]]></content>
		</item>
		
		<item>
			<title>Go 语言错误处理 2</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_errors2/</link>
			<pubDate>Fri, 18 Dec 2020 15:24:34 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_errors2/</guid>
			<description>怎么根据实际情况给出恰当的错误值 构建错误值体系的基本方式有两种，即：创建立体的错误类型体系和创建扁平的错误值列表。 错误类型体系 由于在 Go 语言中</description>
			<content type="html"><![CDATA[<h2 id="怎么根据实际情况给出恰当的错误值">怎么根据实际情况给出恰当的错误值</h2>
<p>构建错误值体系的基本方式有两种，即：创建立体的错误类型体系和创建扁平的错误值列表。</p>
<h3 id="错误类型体系">错误类型体系</h3>
<p>由于在 <code>Go</code> 语言中实现接口是非侵入式的，所以可以做的很灵活。比如，在标准库 <code>net</code> 代码包中有一个名为 <code>Error</code> 的接口类型。它算是内建接口类型 <code>error</code> 的一个扩展接口，因为 <code>error</code> 是 <code>net.Error</code> 的嵌入接口。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// An Error represents a network error.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Error</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kt">error</span>
	<span class="nf">Timeout</span><span class="p">()</span> <span class="kt">bool</span>   <span class="c1">// Is the error a timeout?
</span><span class="c1"></span>	<span class="nf">Temporary</span><span class="p">()</span> <span class="kt">bool</span> <span class="c1">// Is the error temporary?
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><code>net.Error</code> 接口除了拥有 <code>error</code> 接口的 <code>Error</code> 方法之外，还有两个自己声明的方法：<code>Timeout</code> 和 <code>Temporary</code>。</p>
<p><code>net</code> 包中很多错误类型都实现了 <code>net.Error</code> 接口，如：</p>
<ol>
<li><code>*net.OpError</code></li>
<li><code>*net.AddrError</code></li>
<li><code>net.UnKnownNetworkError</code> 等</li>
</ol>
<p>我们可以把这些错误类型想象成一棵树，内建函数 <code>error</code> 就是树的根，而 <code>net.Error</code> 就是树一个在根上延伸的第一级非叶子节点。</p>
<p>同时，也可以把这看作是一种多层分类的手段。当 <code>net</code> 包的使用者拿到一个错误值的时候，可以判断它是否是 <code>net.Error</code> 类型的，也就是说该值是否代表了一个网络相关的错误。如果是，还可以再进一步判断它的类型是哪一个更具体的错误类型，这样就能知道这个网络相关的错误是由于操作不当引起的，还是因为网络地址错误引起的，又或是由于网络协议不正确引起的。</p>
<p>当我们细看 <code>net</code> 包中的这些具体错误类型的实现时，还会发现与 <code>os</code> 包中的一些错误类型相似，它们也都有一个名为 <code>Err</code> 类型为 <code>error</code> 接口类型的字段，代表也是当前错误的潜在错误。</p>
<p>所以说，这些错误值之间还可以有另一种关系，链式关系。比如，使用者调用 <code>net.DialTCP</code> 之类的函数时，<code>net</code> 包中的代码可能返回一个 <code>*net.OpError</code> 类型的错误值，以表示由于他的操作不当造成了一个错误。同时，这些代码还可能把一个 <code>*net.AddrError</code> 或 <code>net.UnKnownNetworkError</code> 类型的值赋给该错误值的 <code>Err</code> 字段，以表明导致这个错误的潜在原因。如此，这里的潜在错误值的 <code>Err</code> 字段也有非 <code>nil</code> 的值，那么将会指向更深层次的错误原因。这样一级又一级就像链条一样最终指向问题的根源。</p>
<p>以上这些内容总结成一句话就是，用类型建立起树形结果的错误体系，用统一字段建立起可追根溯源的链式错误关联。这是 <code>Go</code> 语言标准库给与我们的优秀范本，非常有借鉴意义。</p>
<p>注意，如果不希望包外代码改动返回的错误值的话，一定要小写其中字段名称首字母。我们可以通过暴露某些方法让包外代码有进一步获取错误信息的权限，比如编写一个可以返回一个包级私有的 <code>err</code> 字段值的公开方法 <code>Err</code>。</p>
<h3 id="错误值列表">错误值列表</h3>
<p>当我们只想预先创建一些代表已知错误的错误值时，用这种扁平化的方式就很恰当了。不过，由于 <code>error</code> 是接口类型，所以通过 <code>errors.New</code> 函数生成的错误值只能赋给变量，而不能赋给常量，又由于这些代表错误的变量需要给包外代码使用，所以其访问权限只能是公开的。</p>
<p>这就带来一个问题，如果有恶意代码修改了这些公开变量的值，那么程序就必然会受到影响。因为这种情况下我们往往会通过判等操作来判断拿到的错误值具体是哪一个错误，如果这些公开变量的值被改变了，那么相应的判等操作也会随之改变。</p>
<p>这里有两个解决方案：</p>
<h4 id="第一个方案">第一个方案</h4>
<p>先私有化此类变量。也就是说，让它们名称首字母变成小写，然后编写公开的用于获取错误值以及用于判等错误值的函数。</p>
<p>比如，对于错误值 <code>os.ErrClosed</code>，先改写它的名称，让其变成 <code>os.errClosed</code>，然后再编写 <code>ErrClosed</code> 函数和 <code>IsErrClosed</code> 函数。</p>
<p>当然了，这不是说让我们去改动标准库中已有的代码，这样做的危害会很大，甚至是致命的。只能说，对于我们可控的代码，最好还是要尽量收紧访问权限。</p>
<h4 id="第二个方案">第二个方案</h4>
<p>此方案存在于 <code>syscall</code> 包中。该包中有一个类型叫做 <code>Errno</code>，该类型代表了系统调用时可能发生的底层错误。这个错误类型是 <code>error</code> 接口的实现类型，同时也是对内建类型 <code>uintptr</code> 的在定义类型。</p>
<p>由于 <code>uintptr</code> 可以作为常量的类型，所以 <code>syscall.Errno</code> 自然也可以。<code>syscall</code> 包中声明有大量的 <code>Errno</code> 类型的常量，每个常量对应一种系统调用错误。<code>syscall</code> 包外的代码可以拿到这些代表错误的常量，但无法改变它们。</p>
<p>我们可以仿照这种声明方式来构建我们自己的错误值列表，这样就可以保证错误值的只读特性了。</p>
]]></content>
		</item>
		
		<item>
			<title>Go 语言错误处理</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_errors/</link>
			<pubDate>Fri, 18 Dec 2020 14:12:32 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_errors/</guid>
			<description>error 类型是一个接口类型，也是一个 Go 语言的内建类型。在这个接口类型的声明中只包含了一个方法 Error。它不接受任何参数，但是返回一个 string 类型的结果</description>
			<content type="html"><![CDATA[<p><code>error</code> 类型是一个接口类型，也是一个 <code>Go</code> 语言的内建类型。在这个接口类型的声明中只包含了一个方法 <code>Error</code>。它不接受任何参数，但是返回一个 <code>string</code> 类型的结果。它的作用是返回错误信息的字符串表示形式。</p>
<p>使用 <code>error</code> 类型的方式通常是，在函数声明的结果列表最后，声明一个该类型的结果，同时在调用这个函数之后，先判断它返回的最好一个结果值是否不为 <code>nil</code>。如果这个值不为 <code>nil</code>，那么进入错误处理流程，否则就继续进行正常流程。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">echo</span><span class="p">(</span><span class="nx">request</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">response</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">request</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;empty request&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">response</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;echo: %s&#34;</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;hello&#34;</span><span class="p">}</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;request: %s\n&#34;</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
		<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">echo</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;error: %s\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在 <code>echo</code> 函数和 <code>main</code> 函数中都是用了卫述语句，它是被用来检查后续操作的前置条件并进行相应处理的语句。对于 <code>echo</code> 函数来说，传入的参数值一定要符合要求。而对于调用它的程序来说，进行后续操作的前提就是 <code>echo</code> 函数的执行不能出错。</p>
<p>生成 <code>error</code> 类型值的时候用到了 <code>errors.New</code> 函数，这是一种最基本的生成错误值的方式。调用它的时候传入一个由字符串代表的错误信息，它会返回一个包含了这个错误信息的 <code>error</code> 类型值。该值的静态类型当然是 <code>error</code>，而动态类型则是一个在 <code>errors</code> 包中的包级私有类型 <code>*errorString</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// because the former will succeed if err wraps an *os.PathError.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">errors</span>

<span class="c1">// New returns an error that formats as the given text.
</span><span class="c1">// Each call to New returns a distinct error value even if the text is identical.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">text</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">errorString</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// errorString is a trivial implementation of error.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">errorString</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">errorString</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><p>显然，<code>errorString</code> 类型拥有的一个指针方法实现了 <code>error</code> 接口中的 <code>Error</code> 方法。这个方法被调用后，会原封不动的返回我们之前传入的错误信息。实际上，<code>error</code> 类型值的 <code>Error</code> 方法就相当于其他类型的 <code>String</code> 方法。</p>
<p>我们知道，通过 <code>fmt.Printf</code> 函数给定占位符 <code>%s</code> 就可以打印出某个值的字符串表示形式，对于其他类型来说，只有为这个类型编写了 <code>String</code> 方法，就可以自定义它的字符串表示形式。而对于 <code>error</code> 类型值，它的字符串表示形式则取决于它的 <code>Error</code> 方法。</p>
<p>在上述情况下，<code>fmt.Printf</code> 函数如果发现一个被打印的值是一个 <code>error</code> 类型的值，那么会去调用它的 <code>Error</code> 方法。<code>fmt</code> 包中的这类打印函数其实都是这么做的。</p>
<p>当需要通过模板化的方式生成错误信息并得到错误值时，可以使用 <code>fmt.Errorf</code> 函数。该函数所做的其实就是先调用 <code>fmt.Sprintf</code> 函数，得到确切的错误信息，再调用 <code>errors.New</code> 函数，得到包含该错误信息的 <code>error</code> 类型值，最后返回该值。</p>
<h2 id="怎么判断一个错误值代表的哪类错误">怎么判断一个错误值代表的哪类错误</h2>
<ul>
<li>对于类型在已知范围内的一系列错误值，一般使用类型断言表达式或类型 <code>switch</code> 语句来判断。</li>
<li>对于已有相应变量且类型相同的一系列错误值，一般直接使用判等操作来判断。</li>
<li>对于没有相应变量且类型未知的一系列错误值，只能使用错误信息的字符串表示形式来判断。</li>
</ul>
<h3 id="类型在已知范围内的错误值">类型在已知范围内的错误值</h3>
<p>拿 <code>os</code> 包中的几个代表错误的类型 <code>os.PathError</code>、<code>os.LinkError</code>、<code>os.SyscallError</code> 和 <code>os/exec.Error</code> 来说，它们的指针类型都是 <code>error</code> 接口的实现类型，同时它们也都包含了一个名叫 <code>Err</code>，类型为 <code>error</code> 接口类型的代表潜在错误的字段。</p>
<p>如果我们得到一个 <code>error</code> 类型值，并且知道该值的实际类型肯定是它们中的一个，那么就可以用 <code>switch</code> 语句去判断：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">underlyingError</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">PathError</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Err</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">LinkError</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Err</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">SyscallError</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Err</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">exec</span><span class="p">.</span><span class="nx">Error</span>
		<span class="k">return</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><p>函数 <code>underlyingError</code> 的作用是：获取和返回已知操作系统相关错误的潜在错误值。其中 <code>switch</code> 语句中若干个 <code>case</code> 子句分别对应了上述的几种错误类型，当它们被选中时，都会把参数 <code>err</code> 的 <code>Err</code> 字段作为结果值返回。如果它们都未被选中，那么该函数就把参数值当做结果返回，即放弃获取潜在错误值。</p>
<p>只要类型不同，我们就可以如此分辨。但在错误类型相同的情况下，这些手段就无能为力了。在 <code>Go</code> 语言标准库中也有不少以相同方式创建同类型的错误值。</p>
<p>还拿 <code>os</code> 包来说，其中不少错误值都是通过调用 <code>errors.New</code> 来初始化的，比如：<code>os.ErrClosed</code>、<code>os.ErrInvalid</code> 以及 <code>os.ErrPermission</code> 等。</p>
<p>注意，与前面的几个错误类型不同，这几个都是已经定义好的、确切的错误值。<code>os</code> 包中的代码有时候会把它们当做潜在错误值封装进前面那些错误类型值中。</p>
<p>如果我们在操作文件系统的时候得到了一个错误值，并且知道该值的潜在错误值肯定是上述值中的某一个，那么就可以用普通的 <code>switch</code> 语句去做判断，当然了，<code>if</code> 语句和判等操作符也是可以的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">printError</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;nil error&#34;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nf">underlyingError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="k">switch</span> <span class="nx">err</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">os</span><span class="p">.</span><span class="nx">ErrClosed</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;error(closed)[%d]: %s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">case</span> <span class="nx">os</span><span class="p">.</span><span class="nx">ErrInvalid</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;error(invalid)[%d]: %s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">case</span> <span class="nx">os</span><span class="p">.</span><span class="nx">ErrPermission</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;error(permission)[%d]: %s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这个由 <code>printError</code> 变量代表的函数会接受一个 <code>error</code> 类型的参数值。该值总会代表某个文件操作相关的错误，这是我故意地以不正确的方式操作文件后得到的。</p>
<p>虽然我不知道这些错误值的类型的范围，但却知道它们或它们的潜在错误值一定是某个已经在 <code>os</code> 包中定义的值。</p>
<p>所以，我先用 <code>underlyingError</code> 函数得到它们的潜在错误值，当然也可能只得到原错误值而已。然后，我用 <code>switch</code> 语句对错误值进行判等操作，三个 <code>case</code> 子句分别对应我刚刚提到的那三个已存在于 <code>os</code> 包中的错误值。如此一来，我就能分辨出具体错误了。</p>
<p>对于上面这两种情况，我们都有明确的方式去解决。但是，如果我们对一个错误值可能代表的含义知之甚少，那么就只能通过它拥有的错误信息去做判断了。</p>
<p>好在我们总是能通过错误值的 <code>Error</code> 方法，拿到它的错误信息。其实 <code>os</code> 包中就有做这种判断的函数，比如：<code>os.IsExist</code>、<code>os.IsNotExist</code> 和 <code>os.IsPermission</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">printError2</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;nil error&#34;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nf">underlyingError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;error(exist)[%d]: %s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;error(not exist)[%d]: %s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsPermission</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;error(permission)[%d]: %s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;error(other)[%d]: %s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go 语言流程控制语句</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_control/</link>
			<pubDate>Fri, 18 Dec 2020 09:33:24 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_control/</guid>
			<description>for 语句 带 range 的 for 有哪些细节 range 左边的变量只有一个时代表索引值，有两个时，一个索引值，一个元素值。 数组的 range 不会修改原值，切片的 range 会影响底层数组。 numbers</description>
			<content type="html"><![CDATA[<h2 id="for-语句"><code>for</code> 语句</h2>
<h3 id="带-range-的-for-有哪些细节">带 <code>range</code> 的 <code>for</code> 有哪些细节</h3>
<p><code>range</code> 左边的变量只有一个时代表索引值，有两个时，一个索引值，一个元素值。</p>
<p>数组的 <code>range</code> 不会修改原值，切片的 <code>range</code> 会影响底层数组。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">numbers</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">numbers</span><span class="p">{</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
        <span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">|=</span> <span class="nx">i</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>

<span class="c1">// [1 2 3 7 5 6]
</span></code></pre></div><p>当 <code>for</code> 语句执行时，<code>range</code> 右边的 <code>numbers</code> 会先被求值。这里的代码被称为 <code>range</code> 表达式，它的结果可以是数组、数组的指针、切片、字符串、字典或接收通道中的一个，并且只能一个。</p>
<p>对于不同种类的 <code>range</code> 表达式结果值，<code>for</code> 语句的迭代变量的数量可以不同。以上面例子来说，它是一个切片，那么迭代变量可以有两个，右边的迭代变量代表档次迭代对应的某一个元素值，左边的迭代变量则代表该元素在切片中的索引值。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">numbers</span><span class="p">{}</span> <span class="c1">// k是索引值，v是元素值
</span></code></pre></div><p>那么，如果像例子中那样只有一个迭代变量则只会代表档次迭代对应的元素值的索引值。当只有一个迭代变量时，数组、数组的指针、切片和字符串的元素值都是无处安放的，我们只能拿到按照从小到大顺序给出的一个个索引值。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 数组
</span><span class="c1"></span><span class="nx">numbers</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="nx">maxIndex</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">numbers</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">maxIndex</span> <span class="p">{</span>
        <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">numbers</span><span class="p">[</span><span class="nx">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>

<span class="c1">// [7 3 5 7 9 11]
</span></code></pre></div><p>这里需要注意两点：</p>
<ul>
<li><code>range</code> 表达式只会在 <code>for</code> 语句开始执行时求值一次，无论后面有多少次迭代。</li>
<li><code>range</code> 表达式的求值结果会被复制，就是说被迭代的对象是 <code>range</code> 表达式结果值的副本而不是原值。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 切片
</span><span class="c1"></span><span class="nx">numbers</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="nx">maxIndex</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">numbers</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">maxIndex</span> <span class="p">{</span>
        <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">numbers</span><span class="p">[</span><span class="nx">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>

<span class="c1">// [22 3 6 10 15 21]
</span></code></pre></div><p>切片与数组是不同的，前者是引用类型的，而后者是值类型的。</p>
<h2 id="switch-语句"><code>switch</code> 语句</h2>
<h3 id="switch-和-case-有什么联系"><code>switch</code> 和 <code>case</code> 有什么联系</h3>
<p>由于需要判等操作，所以两者之间的表达式结果值类型需要相同。</p>
<p><code>switch</code> 语句会进行有限的类型转换，但这不能保证类型的统一。</p>
<p>如果某个表达式的结果值类型是接口类型，一定要小心检查它们的动态值是否具有可比性。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">numbers</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int8</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="k">switch</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;0 or 1&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;2 or 3&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;4 or 5 or 6&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//	.\main1.go:8:2: invalid case numbers[0] in switch on 1 + 3 (mismatched types int8 and int)
</span><span class="c1">//	.\main1.go:8:2: invalid case numbers[1] in switch on 1 + 3 (mismatched types int8 and int)
</span><span class="c1">//	.\main1.go:10:2: invalid case numbers[2] in switch on 1 + 3 (mismatched types int8 and int)
</span><span class="c1">//	.\main1.go:10:2: invalid case numbers[3] in switch on 1 + 3 (mismatched types int8 and int)
</span><span class="c1">//	.\main1.go:12:2: invalid case numbers[4] in switch on 1 + 3 (mismatched types int8 and int)
</span><span class="c1">//	.\main1.go:12:2: invalid case numbers[5] in switch on 1 + 3 (mismatched types int8 and int)
</span><span class="c1">//	.\main1.go:12:2: invalid case numbers[6] in switch on 1 + 3 (mismatched types int8 and int)
</span></code></pre></div><p><code>switch</code> 表达式的结果值与某个 <code>case</code> 表达式中任何一个子表达式的结果值相等，该 <code>case</code> 表达式所属的 <code>case</code> 就被选中，其附带的语句就会被执行，同时，其他的 <code>case</code> 子句就会被忽略。除非被选中的子句中包含了 <code>fallthrough</code> 语句，那么紧挨着它的下一个 <code>case</code> 也会被执行。</p>
<p>正因为存在上述判等操作，<code>switch</code> 语句对 <code>switch</code> 表达式以及各个 <code>case</code> 表达式的结果类型是有要求的。毕竟，<code>Go</code> 语言中只有类型相同的值之间才可能被允许进行判等操作。</p>
<p>如果 <code>switch</code> 表达式的结果值是无类型的常量，比如 1 + 3 的求值结果就是无类型常量 4，那么这个常量会自动转换为此常量默认类型的值，比如整数 4 的默认类型是 <code>int</code>，比如浮点数 3.14 的默认类型是 <code>float</code>。</p>
<p>因此，上述代码中 <code>switch</code> 表达式的结果值是 <code>int</code> 类型，而 <code>case</code> 表达式的结果值是 <code>int8</code>，它们的类型并不相同，所以这里是无法通过编译的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">numbers</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int8</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="k">switch</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;0 or 1&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;2 or 3&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;4 or 5 or 6&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 4 or 5 or 6
</span></code></pre></div><p>与刚才那个例子相反，这个例子的 <code>switch</code> 表达式结果值类型是 <code>int8</code>，而 <code>case</code> 表达式的结果值类型是无类型常量，却可以通过编译并成功执行。</p>
<p>这是因为，如果 <code>case</code> 表达式的结果值是无类型的常量，那么它的类型会被自动转换为 <code>switch</code> 表达式的结果类型，又由于上述几个整数都可以被转换为 <code>int8</code> 类型，所以这些表达式的结果值进行判等操作是没问题的。</p>
<p>当然了，如果自动转换没有成功，还是不能通过编译的。</p>
<p><p class="md__image">
  <img src=".././image/91add0a66b9956f81086285aabc20c1c.png"
    alt=""  />
</p>
</p>
<h3 id="switch-语句对-case-表达式有哪些约束"><code>switch</code> 语句对 <code>case</code> 表达式有哪些约束</h3>
<p><code>switch</code> 在 <code>case</code> 子句的选择上是具有唯一性的。它不允许 <code>case</code> 表达式的结果值存在相等的情况，不论这些结果值是否在同一个 <code>case</code> 表达式中。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">numbers</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int8</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="k">switch</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;0 or 1 or 2&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;2 or 3 or 4&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;4 or 5 or 6&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//	.\main1.go:38:7: duplicate case 2 in switch
</span><span class="c1">//	previous case at .\main1.go:36:13
</span><span class="c1">//	.\main1.go:40:7: duplicate case 4 in switch
</span><span class="c1">//	previous case at .\main1.go:38:13
</span></code></pre></div><p>由于在这三个 <code>case</code> 表达式中存在结果值相等的子表达式，所以这个 <code>switch</code> 语句无法通过编译。不过，好在这个约束本身还有个约束，那就是只针对结果值为常量的子表达式。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">numbers</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int8</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="k">switch</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;0 or 1 or 2&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;2 or 3 or 4&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;4 or 5 or 6&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 2 or 3 or 4
</span></code></pre></div><p>把 <code>case</code> 表达式中的常量都换成了诸如 <code>numbers[4]</code> 这样的索引表达式，可以绕过上述约束条件。</p>
<p>不过，这种绕过方式对用于类型判断的 <code>switch</code> 语句无效，因为 <code>switch</code> 和 <code>case</code> 表达式都必须由类型字面量来表示，不能通过间接的方式表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">numbers</span> <span class="o">:=</span> <span class="kd">interface</span><span class="p">{}(</span><span class="nb">byte</span><span class="p">(</span><span class="mi">127</span><span class="p">))</span>
<span class="k">switch</span> <span class="nx">t</span> <span class="o">:=</span> <span class="nx">numbers</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;uint8 or uint16&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="kt">byte</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;byte&#34;</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;unsupported type: %T&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//	.\main1.go:63:2: duplicate case byte in type switch
</span><span class="c1">//		previous case at .\main1.go:61:2
</span></code></pre></div><p><code>byte</code> 类型是 <code>uint8</code> 类型的别名，它们本质上是同一个类型，只是名称不同。这种情况下，是不能通过编译的，因为表达式 <code>byte</code> 和 <code>uint8</code> 重复了。</p>
]]></content>
		</item>
		
		<item>
			<title>Go 语言及其执行规则 2</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_goroutine2/</link>
			<pubDate>Thu, 17 Dec 2020 16:59:29 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_goroutine2/</guid>
			<description>怎样让主 goroutine 等待其他 goroutine 一旦主 goroutine 执行完毕，当前的 Go 程序就会结束运行，无论其他的 goroutine 是否已经在运行了。很多时候我们需要等待其他的 goroutine 的执行结果才让主 goroutine</description>
			<content type="html"><![CDATA[<h2 id="怎样让主-goroutine-等待其他-goroutine">怎样让主 <code>goroutine</code> 等待其他 <code>goroutine</code></h2>
<p>一旦主 <code>goroutine</code> 执行完毕，当前的 <code>Go</code> 程序就会结束运行，无论其他的 <code>goroutine</code> 是否已经在运行了。很多时候我们需要等待其他的 <code>goroutine</code> 的执行结果才让主 <code>goroutine</code> 结束运行，来看下怎么做：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}()</span>
<span class="p">}</span>

<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span>
</code></pre></div><p>最简单粗暴的方法就是让程序在这里睡一会儿，等待其他 <code>goroutine</code> 执行完成后再结束运行，但是这个时间不好控制。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">num</span> <span class="o">:=</span> <span class="mi">10</span>
<span class="nx">sign</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">num</span><span class="p">)</span>

<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
        <span class="nx">sign</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
    <span class="p">}()</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
    <span class="o">&lt;-</span><span class="nx">sign</span>
<span class="p">}</span>
</code></pre></div><p>使用通道，每个手动启用的 <code>goroutine</code> 即将运行完毕的时候，我们都要向该通道发送一个值。注意，这些发送表达式应该被放在它们的 <code>go</code> 函数体的最后面。对应的，我们还需要在 <code>main</code> 函数的最后从通道接收元素值，接收的次数也应该与手动启用的 <code>goroutine</code> 的数量保持一致。</p>
<p>这里有一个细节。在声明通道 <code>sign</code> 的时候是以 <code>chan struct{}</code> 作为其类型的。其中的类型字面量 <code>struct{}</code> 有些类似于空接口类型 <code>interface{}</code>，它代表了既不包含任何字段也不拥有任何方法的空结构体类型。</p>
<p><code>struct{}</code> 类型值的表示法只有一个，即：<code>struct{}{}</code>。并且，它占用的内存空间是 0 字节。确切地说，这个值在整个 <code>Go</code> 程序中永远都只会存在一份。虽然我们可以无数次地使用这个值字面量，但是用到的却都是同一个值。</p>
<p>当我们仅仅把通道当作传递某种简单信号的介质的时候，用 <code>struct{}</code> 作为其元素类型是再好不过的了。</p>
<p>使用 <code>sync.WaitGroup</code></p>
<h2 id="怎样让多个手动启用的-goroutine-按照既定顺序执行">怎样让多个手动启用的 <code>goroutine</code> 按照既定顺序执行</h2>
<p>首先，需要把 <code>i</code> 传入 <code>go</code> 函数，保证每个 <code>goroutine</code> 可以拿到一个唯一的整数。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">count</span> <span class="kt">uint32</span>
<span class="nx">trigger</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">uint32</span><span class="p">,</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">count</span><span class="p">);</span> <span class="nx">n</span> <span class="o">==</span> <span class="nx">i</span> <span class="p">{</span>
            <span class="nf">fn</span><span class="p">()</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Nanosecond</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fn</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">trigger</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
    <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">trigger</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{})</span>
</code></pre></div><p><code>go</code> 函数中声明了一个匿名函数，并把它赋给了变量 <code>fn</code>，该函数只是打印参数 <code>i</code> 的值。</p>
<p>之后调用了 <code>trigger</code> 函数，并把参数 <code>i</code> 和 变量 <code>fn</code> 作为参数传给了它。</p>
<p><code>trigger</code> 函数接受两个参数，一个是 <code>uint32</code> 类型的参数 <code>i</code>，一个是 <code>func()</code> 类型的参数 <code>fn</code>，它会不断的获取变量 <code>count</code> 的值，并判断该值是否与参数 <code>i</code> 的值相同。如果相同，那么立即调用参数 <code>fn</code> 代表的函数，然后把 <code>count</code> 的值加 1，最后显示的退出当前循环。否则就让当前 <code>goroutine</code> 睡一个纳秒再进入下一个迭代。</p>
<p>这里对变量 <code>count</code> 的操作都是原子性的。由于 <code>trigger</code> 函数会被多个 <code>goroutine</code> 并发调用，所以它用到的非本地变量 <code>count</code> 被多个用户级线程公用了。因此，对它的操作就产生了竞态条件（race condition），这破坏了程序的并发安全性。所以我们总是应该对这样的操作加以保护，在 <code>sync/atomic</code> 包中声明了很多用于原子操作的函数。</p>
<p>因为选用的原子操作的函数对被操作的数值有类型约束，所以这里的类型都改成了 <code>uint32</code>。</p>
<p>这里要做的就是让 <code>count</code> 变量称为一个信号，它的值总是下一个可以调用打印函数的 <code>go</code> 函数的序号。这个序号就是启用 <code>goroutine</code> 时的那个当次迭代的序号，也因为如此，<code>go</code> 函数实际的运行顺序才会与 <code>go</code> 语句的执行顺序完全一致。此外，这里的 <code>trigger</code> 函数实现了一种自旋（spinning）。除非发现条件以满足，否则会不断的进行检查。</p>
<p>最后，因为依然想让主 <code>goroutine</code> 最后一个运行完毕，所以这里加了一行代码 <code>trigger(10, func() {})</code>。当所有手动启动的 <code>goroutine</code> 都运行完毕后，<code>count</code> 一定会变成 10，所以把 10 作为第一个参数，然后又不想打印这个 10，所以传了个什么都不做的函数。</p>
<p>通过上面这个例子，使得异步发起的 <code>go</code> 函数得到了同步执行。</p>
]]></content>
		</item>
		
		<item>
			<title>Go 语言及其执行规则</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_goroutine/</link>
			<pubDate>Thu, 17 Dec 2020 15:32:58 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_goroutine/</guid>
			<description>Don’t communicate by sharing memory; share memory by communicating. 从 Go 语言编程的角度解释，这句话的意思是：不要通过共享数据来通讯，要以通讯的方式来共享数据。 通道（channel）类</description>
			<content type="html"><![CDATA[<blockquote>
<p>Don’t communicate by sharing memory; share memory by communicating.</p>
</blockquote>
<p>从 <code>Go</code> 语言编程的角度解释，这句话的意思是：不要通过共享数据来通讯，要以通讯的方式来共享数据。</p>
<p>通道（channel）类型的值，可以被用来以通讯的方式共享数据。它一般被用来在不同的 <code>goroutine</code> 之间传递数据。</p>
<p><code>goroutine</code> 代表着并发编程模型中的用户级线程。</p>
<h2 id="进程和线程">进程和线程</h2>
<p>进程，描述的是程序的执行过程，是运行着的程序的代表。换句话说，一个进程就是某个程序运行时的一个产物。如果说静静躺在那里的代码就是程序的话，那么奔跑的、正在发挥着既有功能的代码就可以被称为进程。</p>
<p>线程，总是在进程之内，它可以被视为进程中运行着的控制流（或者说代码执行的流程）。一个进程至少会包含一个线程。</p>
<p>如果一个进程只包含了一个线程，那么它里面所有的代码只会被串行的执行。每个进程的第一个线程都会随着进程的启动而被创建，它们可以被称为其所属进程的主线程。</p>
<p>如果一个进程包含了多个线程，那么它里面的所有代码就可以被并发的执行。除了进程的第一个线程之外，其他线程都是由进程中已存在的线程创建出来的。</p>
<p>也就是说，主线程之外的其他线程都只能由代码显示的创建和摧毁。这需要我们在编写程序的时候进行手动控制，操作系统以及进程本身并不会帮我们下达这样的指令，它们只会忠实的执行我们的指令。</p>
<h2 id="用户级线程-goroutine">用户级线程 <code>goroutine</code></h2>
<p>不过，<code>Go</code> 程序当中，<code>Go</code> 语言的运行时（runtime）系统会帮我们自动创建和销毁系统级线程。这里的系统级线程就是指我们刚刚说过的操作系统提供的线程。</p>
<p>而对应的用户级线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程。用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都需要我们的程序自己去实现和处理。</p>
<p>优势：它们的创建和销毁不需要通过操作系统，速度会很快。不用等待操作系统的调度，容易控制并且很灵活。</p>
<p>劣势：复杂，我们既是命令下达者又是命令执行者，我们必须全权负责与用户级线程有关的所有具体实现。</p>
<h2 id="goroutine-调度器"><code>goroutine</code> 调度器</h2>
<p>这个调度器是 <code>Go</code> 语言运行时系统的重要组成部分，它主要负责统筹调配 <code>Go</code> 并发编程模型中的三个主要元素，即：G（<code>goroutine</code> 的缩写）、P （<code>processor</code> 的缩写）和 M（<code>machine</code> 的缩写）。</p>
<p>其中的 <code>M</code> 指代的就是系统级线程。而 <code>P</code> 指的是一种可以承载若干个 <code>G</code>，且能够使这些 <code>G</code> 适时的与 <code>M</code> 进行对接，并得到真正运行的中介。</p>
<p>从宏观上说，<code>G</code> 和 <code>M</code> 由于 <code>P</code> 的存在可以呈现出多对多的关系。当一个正在与某个 <code>M</code> 对接并运行着的 <code>G</code>，需要因某个事件（比如等待 <code>I/O</code> 或者锁的解除）而暂停运行的时候，调度器总会及时的发现，并把这个 <code>G</code> 和 <code>M</code> 分离开，以释放计算资源供那些正在等待运行的 <code>G</code> 使用。</p>
<p>而当一个 <code>G</code> 需要恢复运行的时候，调度器又会尽快的为它寻找空闲的计算资源（包括 <code>M</code>）并安排运行。另外，当 <code>M</code> 不够用时，调度器会帮我们向操作系统申请新的系统级线程，而当某个 <code>M</code> 已无用时，调度器又会负责及时的把它销毁掉。</p>
<p>正因为调度器帮助我们做了很多事，所以我们的 <code>Go</code> 程序才总是能高效的利用操作系统和计算机资源。程序中的所有 <code>goroutine</code> 也都会被充分的调度，其中的代码也都会被并发的运行，即使这样的 <code>goroutine</code> 数以万计，也仍然可以如此。</p>
<p><p class="md__image">
  <img src=".././image/9ea14f68ffbcde373ddb61e186695d7d.png"
    alt=""  />
</p>
</p>
<h2 id="什么是主-goroutine它和我们启用的其他-goroutine-有什么不同">什么是主 <code>goroutine</code>，它和我们启用的其他 <code>goroutine</code> 有什么不同</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
		<span class="p">}()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 没有任何输出
</span></code></pre></div><p>与一个进程总会有一个主线程类似，每一个独立的 <code>Go</code> 程序在运行时也总会有一个主 <code>goroutine</code>。这个主 <code>goroutine</code> 会在 <code>Go</code> 程序的运行准备工作完成后被自动启用，不需要我们做任何手动操作。</p>
<p>每条 <code>go</code> 语句一般都会携带一个函数调用，这个被调用的函数常常被称为 <code>go</code> 函数。而主 <code>goroutine</code> 的 <code>go</code> 函数就是那个作为程序入口的 <code>main</code> 函数。</p>
<p>注意，<code>go</code> 函数真正被执行的时间，总会与其所属的 <code>go</code> 语句被执行的时间不同。当程序执行到一条 <code>go</code> 语句的时候，<code>Go</code> 语言运行时系统会先试图从某个存放空闲的 <code>G</code> 的队列中获取一个 <code>G</code>，只有在找不到空闲 <code>G</code> 的情况下才会去创建一个新的 <code>G</code>。已存在的 <code>goroutine</code> 总会被优先复用。</p>
<p>创建一个 <code>G</code> 的成本也是非常低的。创建一个 <code>G</code> 并不像新建一个进程或者一个系统级线程那样需要操作系统来完成，在 <code>Go</code> 语言的运行时系统内部就可以完成，更何况一个 <code>G</code> 仅相当于为需要并发执行的代码片段服务的上下文而已。</p>
<p>拿到一个空闲的 <code>G</code> 后，运行时系统会用这个 <code>G</code> 去包装当前的那个 <code>go</code> 函数（或者说该函数中的那些代码），然后把这个 <code>G</code> 追加到某个存放可运行的 <code>G</code> 的队列中。</p>
<p>这类队列中的 <code>G</code> 总是会按照先进先出的顺序，很快的由运行时系统内部的调度器安排执行。虽然很快，但是准备工作不可避免，也是有耗时的。</p>
<p>因此，<code>go</code> 函数的执行时间总是会明显滞后于它所属的 <code>go</code> 语句的执行时间。当然了，这里所说的明显是相对于计算机的 <code>CPU</code> 时钟和 <code>Go</code> 程序。我们大多数都不会有明显的感觉。</p>
<p>只要 <code>go</code> 语句本身执行完毕，<code>Go</code> 程序完全不会等待 <code>go</code> 函数的执行，它会立刻执行后面的语句。这就是所谓的异步并发的执行。</p>
<p>重要特性：一旦主 <code>goroutine</code> 中的代码（也就是 <code>main</code> 函数中的代码）执行完毕，当前的 <code>Go</code> 程序就会结束运行。这时候如果有 <code>goroutine</code> 还没有执行，就永远不再执行了。</p>
<p>严谨的讲，<code>Go</code> 语言并不会保证这些 <code>goroutine</code> 的运行顺序，由于主 <code>goroutine </code> 会与我们手动启用的其他 <code>goroutine </code> 一起接受调度，又因为调度器很可能会在 <code>goroutine </code> 中的代码只执行了一部分的时候暂停，以期所有的 <code>goroutine </code> 有更公平的运行机会。</p>
<p>所以哪个 <code>goroutine </code> 先执行完、哪个 <code>goroutine </code> 后执行完往往是不可预知的，除非我们使用了某种 <code>Go</code> 语言提供的方式进行了人为干预。</p>
<p>由于 <code>G</code> 队列是多个的，我们的 <code>G</code> 不一定被调度到哪一个 <code>G</code> 队列里面等待执行，所以虽然队列是先进先出的，但是 <code>goroutine</code> 的执行结果还是无序的。</p>
]]></content>
		</item>
		
		<item>
			<title>指针的有限操作</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_pointer/</link>
			<pubDate>Thu, 17 Dec 2020 09:06:50 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_pointer/</guid>
			<description>先来看一段代码： type Dog struct { name string } func (dog *Dog) SetName(name string) { dog.name = name } 对于基本类型 Dog 来说，*Dog 就是它的指针类型。而对于一个 Dog 类型，值不为 nil 的变量 dog，取址</description>
			<content type="html"><![CDATA[<p>先来看一段代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dog</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nf">SetName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">dog</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="nx">name</span>
<span class="p">}</span>
</code></pre></div><p>对于基本类型 <code>Dog</code> 来说，<code>*Dog</code> 就是它的指针类型。而对于一个 <code>Dog</code> 类型，值不为 <code>nil</code> 的变量 <code>dog</code>，取址表达式 <code>&amp;dog</code> 的结果就是该变量的值的指针值。</p>
<p>如果一个方法的接收者是 <code>*Dog</code> 类型的，那么该方法就是基本类型 <code>Dog</code> 的指针方法。</p>
<p>在这种情况下，这个方法的接收者实际上就是当前基本值的指针值。</p>
<p>我们可以通过指针值无缝的访问到基本值包含的任何字段，以及调用与之关联的任何方法。这应该就是我们在编写 <code>Go</code> 程序的过程中用的最频繁的指针了。</p>
<p>传统意义来说，指针是一个指向某个确切的内存地址的值。这个内存地址可以是任何数据或代码的起始地址，比如，某个变量、某个字段或某个函数。</p>
<p>刚刚只是提到了一种情况，在 <code>Go</code> 语言中还有其他几样东西可以代表指针。其中最贴近传统意义的当属 <code>uintptr</code> 类型了。该类型实际上是一个数值类型，也是 <code>Go</code> 语言内建的数据类型之一。</p>
<p>根据当前计算机架构的不同，它可以存储 32 位或 64 位的无符号整数，可以代表任何指针的位（bit）模式，也就是原始的内存地址。</p>
<p>再来看 <code>Go</code> 语言标准库中的 <code>unsafe</code> 包。该包中有个类型叫做 <code>Pointer</code>，也代表了指针。</p>
<p><code>unsafe.Pointer</code> 可以表示任何指向可寻址的值的指针，同时它也是前面提到的指针值和 <code>uintptr</code> 值之间的桥梁。通过它，我们可以在两种值之上进行双向转换。这里有个很关键的词&ndash;可寻址（addressable）。</p>
<h2 id="go-语言中那些值是不可寻址的"><code>Go</code> 语言中那些值是不可寻址的</h2>
<ul>
<li>常量的值。</li>
<li>基本类型值的字面量。</li>
<li>算数操作的结果值。</li>
<li>对各种字面量的索引表达式和切片表达式的结果值。例外，对切片字面量的索引结果值是可寻址的。</li>
<li>对字符串变量的索引表达式和切片表达式的结果值。</li>
<li>对字典变量的索引表达式的结果值。</li>
<li>函数字面量和方法字面量，以及对它们的调用表达式的结果值。</li>
<li>结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值。</li>
<li>类型转换表达式的结果值。</li>
<li>类型断言表达式的结果值。</li>
<li>接收表达式的结果值。</li>
</ul>
<p>常量的值总是会被存储到一个确切的内存区域中，并且这种值肯定是<strong>不可变的</strong>。基本类型值的字面量也是一样，它们本就可以被视为常量，只不过没有任何标识符可以代表它们。</p>
<h3 id="不可变的">不可变的</h3>
<p>由于 <code>Go</code> 语言中的字符串值也是不可变的，所以对于一个字符串类型的变量来说，基于它的索引或切片的结果值也都是不可寻址的，因为即使拿到了这种值的地址也改变不了什么。</p>
<p>算数操作的结果属于一种<strong>临时结果</strong>。在我们把这种结果值赋给任何变量或常量之前，即使拿到它的内存地址也是没有任何意义的。</p>
<h3 id="临时结果">临时结果</h3>
<p>我们可以把各种对值字面量施加表达式的求值结果都看作是临时结果。</p>
<p><code>Go</code> 语言中的表达式有很多种，常用的包括以下几种：</p>
<ul>
<li>用于获得某个元素的索引表达式。</li>
<li>用于获得某个切片的切片表达式。</li>
<li>用于访问某个字段的选择表达式。</li>
<li>用于调用某个函数或方法的调用表达式。</li>
<li>用于转换值的类型的类型转换表达式。</li>
<li>用于判断值的类型的类型断言表达式。</li>
<li>向通道发送元素值或从通道那里接收元素值的接收表达式。</li>
</ul>
<p>以上这些表达式施加到某个字面量上一般都会得到一个临时结果，它们都是不可寻址的。</p>
<p>注意，对切片字面量的索引结果值是可寻址的。因为切片会持有一个底层数组，而这个底层数组中的每个元素值都有一个确切的内存地址。</p>
<p>对切片字面量的切片结果值不可寻址是因为切片表达式总会返回一个新的切片值，而这个新的切片值在赋给变量之前属于临时结果。</p>
<p>以上所说都是针对字面量的表达式会产生临时结果，如果针对的是变量，那么索引或者切片就不属于临时结果了，是可寻址的。</p>
<p>注意，对字典类型的变量施加索引表达式，得到的结果值不属于临时结果，但也是不可寻址的。因为字典中的键-元素对的存储位置可能会变化。</p>
<p>字典中有若干个哈希桶用于均匀存储键-元素对。当满足一定条件时，字典可能会改变哈希桶的数量，并把键-元素对重新分布到对应的新的哈希桶中。这样即使拿到字典中任何元素的地址值的指针都毫无意义，也是<strong>不安全的</strong>。我们不知道那个元素值会被分布到哪里，也不知道原来的地址上被存放什么东西。</p>
<h3 id="不安全的">不安全的</h3>
<p>不安全的操作可能会破坏程序一致性，引发不可预知的错误，从而严重影响程序的功能和稳定性。</p>
<p>函数在 <code>Go</code> 语言中是一等公民，我们可以把代表函数或者方法的字面量或标识符赋给某个变量、传给某个函数或者从某个函数传出。但这样的函数和方法都是不可寻址的，因为函数就是代码，是不可变的。另一个原因就是，拿到指向一段代码的指针是不安全的。此外，函数或方法的调用结果值属于临时结果，它们也是不可寻址的。</p>
<p>其他几种值，都是针对值的字面量的某种表达式的结果值，所以属于临时结果，都不可寻址。</p>
<h3 id="小结">小结</h3>
<ol>
<li>不可变的值不可寻址。常量、基本类型值的字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。</li>
<li>绝大多数被视为临时结果的值都是不可寻址的。算数操作的结果值属于临时结果，针对值字面量的结果表达式的值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但确实可寻址的。</li>
<li>若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的，该值就不可寻址。由于字典的内部机制，对字典的索引结果值取址操作都是不安全的。另外，获取有字面量或标识符代表的函数或方法的地址显然也是不安全的。</li>
</ol>
<p>如果把临时结果赋给一个变量，那么它就是可寻址的了。取到的指针指向的就是这个变量持有的那个值了。</p>
<h2 id="不可寻址的值有哪些使用限制">不可寻址的值有哪些使用限制</h2>
<p>无法使用取址标识符 <code>&amp;</code> 获取指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Dog</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">Dog</span><span class="p">{</span><span class="nx">name</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dog</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nf">SetName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">dog</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dog</span> <span class="nx">Dog</span><span class="p">)</span> <span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">dog</span><span class="p">.</span><span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">New</span><span class="p">(</span><span class="s">&#34;little pig&#34;</span><span class="p">).</span><span class="nf">SetName</span><span class="p">(</span><span class="s">&#34;monster&#34;</span><span class="p">)</span> <span class="c1">// 不能调用不可寻址的值的指针方法。
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>通常在基础类型的值上调用指针方法时，<code>Go</code> 语言会自动获取它的指针值，但由于 <code>New</code> 函数的调用结果值是不可寻址的，所以这里无法自动转译，也无法对它进行取址操作。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="p">.</span><span class="err">\</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span> <span class="nx">cannot</span> <span class="nx">call</span> <span class="nx">pointer</span> <span class="nx">method</span> <span class="nx">on</span> <span class="nf">New</span><span class="p">(</span><span class="s">&#34;little pig&#34;</span><span class="p">)</span>
<span class="p">.</span><span class="err">\</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span> <span class="nx">cannot</span> <span class="nx">take</span> <span class="nx">the</span> <span class="nx">address</span> <span class="nx">of</span> <span class="nf">New</span><span class="p">(</span><span class="s">&#34;little pig&#34;</span><span class="p">)</span>
</code></pre></div><p>虽然 <code>Go</code> 语言规范中的语法定义是，只要在 <code>++</code> 或 <code>--</code> 的左边添加一个表达式，就可以组成一个自增语句或自减语句，但是，它还明确了一个很重要的限制，那就是这个表达式的结果值必须是可寻址的。这就使得针对值字面量的表达式几乎都无法被用在这里。</p>
<p>不过这有一个例外，虽然对字典字面量和字典变量索引表达式的结果值都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。</p>
<p>与之类似的规则还有两个。一个是，在赋值语句中，赋值操作符左边的表达式的结果值必须可寻址的，但是对字典的索引结果值也是可以的。</p>
<p>另一个是，在带有 <code>range</code> 子句的 <code>for</code> 语句中，在 <code>range</code> 关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用在这里。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&#34;the&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;word&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;counter&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}[</span><span class="s">&#34;word&#34;</span><span class="p">]</span><span class="o">++</span>
<span class="nx">map1</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&#34;the&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;word&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;counter&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
<span class="nx">map1</span><span class="p">[</span><span class="s">&#34;word&#34;</span><span class="p">]</span><span class="o">++</span>
</code></pre></div><h2 id="怎样通过-unsafepointer-操作可寻址的值">怎样通过 <code>unsafe.Pointer</code> 操作可寻址的值</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dog</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nf">SetName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">dog</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dog</span> <span class="nx">Dog</span><span class="p">)</span> <span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">dog</span><span class="p">.</span><span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 示例1。
</span><span class="c1"></span>	<span class="nx">dog</span> <span class="o">:=</span> <span class="nx">Dog</span><span class="p">{</span><span class="s">&#34;little pig&#34;</span><span class="p">}</span>
	<span class="nx">dogP</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dog</span>
	<span class="nx">dogPtr</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">dogP</span><span class="p">))</span>

	<span class="nx">namePtr</span> <span class="o">:=</span> <span class="nx">dogPtr</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="nx">dogP</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
	<span class="nx">nameP</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">namePtr</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;nameP == &amp;(dogP.name)? %v\n&#34;</span><span class="p">,</span>
		<span class="nx">nameP</span> <span class="o">==</span> <span class="o">&amp;</span><span class="p">(</span><span class="nx">dogP</span><span class="p">.</span><span class="nx">name</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The name of dog is %q.\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">nameP</span><span class="p">)</span>

	<span class="o">*</span><span class="nx">nameP</span> <span class="p">=</span> <span class="s">&#34;monster&#34;</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The name of dog is %q.\n&#34;</span><span class="p">,</span> <span class="nx">dogP</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>

	<span class="c1">// 示例2。
</span><span class="c1"></span>	<span class="c1">// 下面这种不匹配的转换虽然不会引发panic，但是其结果往往不符合预期。
</span><span class="c1"></span>	<span class="nx">numP</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">namePtr</span><span class="p">))</span>
	<span class="nx">num</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">numP</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;This is an unexpected number: %d\n&#34;</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span>

<span class="p">}</span>
</code></pre></div><p>首先声明了一个 <code>Dog</code> 类型的变量 <code>dog</code>，然后用取址操作符 <code>&amp;</code>，取出了它的指针值，并把它赋给了变量 <code>dogP</code>。</p>
<p>最后，我使用了两个类型转换，先把 <code>dogP</code> 转换成了一个 <code>unsafe.Pointer</code> 类型的值，然后紧接着又把后者转换成了一个 <code>uintptr</code> 的值，并把它赋给了变量 <code>dogPtr</code>。这背后隐藏着一些转换规则，如下：</p>
<ol>
<li>一个指针值（比如 <code>*Dog</code> 类型的值）可以被转换为一个 <code>unsafe.Pointer</code> 类型的值，反之亦然。</li>
<li>一个 <code>uintptr</code> 类型的值也可以被转换为一个 <code>unsafe.Pointer</code> 类型的值，反之亦然。</li>
<li>一个指针值无法被直接转换成一个 <code>uintptr</code> 类型的值，反过来也是如此。</li>
</ol>
<p>所以，对于指针值和 <code>uintptr</code> 类型值之间的转换，必须使用 <code>unsafe.Pointer</code> 类型的值作为中转。</p>
<p><code>unsafe.Offsetof</code> 函数用于获取两个值在内存中的起始存储地址之间的偏移量，以字节为单位。</p>
<p>这两个值一个是某个字段的值，另一个是该字段值所属的那个结构体值。我们在调用这个函数的时候，需要把针对字段的选择表达式传给它，比如 <code>dogP.name</code>。</p>
<p>有了这个偏移量，又有了结构体值在内存中的起始存储地址（这里由 <code>dogPtr</code> 变量代表），把它们相加我们就可以得到 <code>dogP</code> 的 <code>name</code> 字段值的起始存储地址了。这个地址由变量 <code>namePtr</code> 代表。</p>
<p>此后，我们可以再通过两次类型转换把 <code>namePtr</code> 的值转换成一个 <code>*string</code> 类型的值，这样就得到了指向 <code>dogP</code> 的 <code>name</code> 字段值的指针值。</p>
<p><code>namePtr</code> 是一个无符号整数，但同时也是一个指向了程序内部数据的内存地址。它可能会给我们带来一些好处，比如可以直接修改埋藏得很深的内部数据。</p>
<p>但是，一旦我们有意或无意地把这个内存地址泄露出去，那么其他人就能够肆意地改动 <code>dogP.name</code> 的值，以及周围的内存地址上存储的任何数据了。</p>
<p>这可能造成灾难性的后果。</p>
]]></content>
		</item>
		
		<item>
			<title>接口类型的合理运用</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_interface/</link>
			<pubDate>Wed, 16 Dec 2020 16:14:01 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_interface/</guid>
			<description>接口的基础知识 接口类型与其他数据类型不同，它是没办法初始化的。具体的说，我们不能通过 new 或者 make 函数创建出一个接口类型的值，也无法用字面量来表示</description>
			<content type="html"><![CDATA[<h2 id="接口的基础知识">接口的基础知识</h2>
<p>接口类型与其他数据类型不同，它是没办法初始化的。具体的说，我们不能通过 <code>new</code> 或者 <code>make</code> 函数创建出一个接口类型的值，也无法用字面量来表示一个接口类型的值。</p>
<p>对于一个接口类型来说，如果没有任何数据类型可以作为它的实现，那么该接口类型的值就不可能存在。</p>
<p>使用关键字 <code>type</code> 和 <code>interface</code>，可以声明一个接口类型，接口类型的字面量和结构体类型看起来很相似，它们都用花括号包裹一些核心信息。只是结构体包裹的是它的字段声明，而接口包裹的是它的方法定义。</p>
<p>接口类型声明中的这些方法所代表的就是该接口的方法集合。一个接口的方法集合就是它的全部特征。</p>
<p>对应任何一个数据类型，只要它的方法集合中完全包含了一个接口的全部特征，那么它就是这个接口的实现类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Pet</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">SetName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span>
	<span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nf">Category</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div><p>只要一个数据类型的方法集合中有这 3 个方法，那么他就一定是 <code>Pet</code> 接口的实现类型。这是一种无侵入式的接口实现方式。</p>
<h3 id="怎样判定一个数据类型的某一个方法实现的就是某接口类型中的某方法">怎样判定一个数据类型的某一个方法实现的就是某接口类型中的某方法</h3>
<p>有两个充分必要条件：</p>
<ul>
<li>两个方法的签名需要完全一致。</li>
<li>两个方法的名称要一模一样。</li>
</ul>
<p>显然，这比判断一个函数是否实现了某个函数类型要更加严格。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span> <span class="c1">// 名字。
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dog</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nf">SetName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">dog</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dog</span> <span class="nx">Dog</span><span class="p">)</span> <span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">dog</span><span class="p">.</span><span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">dog</span> <span class="nx">Dog</span><span class="p">)</span> <span class="nf">Category</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;dog&#34;</span>
<span class="p">}</span>
</code></pre></div><p>上面这个例子，<code>Dog</code> 类型有三个方法，两个值方法，一个指针方法，这意味这它的值方法并不是接口 <code>Pet</code> 的实现，而它的指针方法才是。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">dog</span> <span class="o">:=</span> <span class="nx">Dog</span><span class="p">{</span><span class="s">&#34;little pig&#34;</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">pet</span> <span class="nx">Pet</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">dog</span>
</code></pre></div><p>因此，我们可以声明并初始化一个 <code>Dog</code> 类型的变量 <code>dog</code>，然后把它的指针值赋给类型为 <code>Pet</code> 的变量。</p>
<p>这里有几个名词需要记住，对于一个接口类型的变量来说，我们赋给它的值可以叫做它的实际值（动态值），而该值的类型可以叫做这个变量的实际类型（动态类型）。动态类型这个叫法是相对于静态类型而言的，对于变量 <code>pet</code> 来说，它的静态类型就是 <code>Pet</code>，而它的动态类型会随着我们赋给它的动态值变化。</p>
<p>在给一个接口类型的变量赋予实际值之前，它的动态类型是不存在的。</p>
<h2 id="为一个接口变量赋值时会发生什么">为一个接口变量赋值时会发生什么</h2>
<p>如果我们使用一个变量给另外一个变量赋值，那么真正赋值给后者的，并不是前者所持有的那个值，而是该值的一个副本。</p>
<p>接口本身是无法被值化的。在赋予它实际的值之前，它的值是 <code>nil</code>，这也是它的零值。</p>
<p>当我们给一个接口变量赋值时，该变量的动态类型会与它的动态值一起被存储再一个专用的数据结构中。这个结构在 <code>Go</code> 语言运行时系统 <code>runtime</code> 包中叫做 <code>iface</code>。它的实例包含两个指针，一个指向类型信息，一个指向动态值。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使用它实现了接口的方法和调用它们的途径等。</p>
<p>总之，接口变量被赋予动态值时，存储的是包含了这个动态值的副本的一个结构更加复杂的值。</p>
<h2 id="接口变量的值在什么情况下才为-nil">接口变量的值在什么情况下才为 <code>nil</code></h2>
<p><code>Go</code> 语言中，我们把字面量 <code>nil</code> 表示的值叫做无类型的 <code>nil</code>。这是真正的 <code>nil</code>，因为它的类型也是 <code>nil</code> 的。上面说了，当我们给接口变量赋值时，<code>Go</code> 语言会用 <code>iface</code> 的实例包装它，包装后的产物就不是 <code>nil</code> 了。</p>
<p>只要我们把一个有类型的 <code>nil</code> 赋给变量接口，那么这个变量的值就一定不会是真正的 <code>nil</code>。</p>
<p>只有在只声明但不初始化或者直接把字面量 <code>nil</code> 赋给它这两种情况下才真正为 <code>nil</code>。</p>
<h2 id="怎样实现接口直接的组合">怎样实现接口直接的组合</h2>
<p>接口类型间的嵌入也叫做接口的组合，它比结构体类型的嵌入简单点，因为它不会涉及方法间的屏蔽。只要组合的接口之间有同名方法就会产生冲突，从而无法通过编译，即使同名方法的签名不同也会如此。因此，接口的组合根本不可能导致屏蔽现象。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Animal</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">ScientificName</span><span class="p">()</span> <span class="kt">string</span>
  <span class="nf">Category</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Pet</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Animal</span>
  <span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div><p><code>Go</code> 语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程序、增加程序的灵活性。</p>
<p>这是因为相比于包含很多方法的大接口而言，小接口可以更加专注的表达某一种能力或某一类特征，同时也更容易被组合在一起。</p>
<p><code>Go</code> 语言标准库代码包 <code>io</code> 中的 <code>ReadWriteCloser</code> 接口和 <code>ReadWriter</code> 接口就是这样的例子，它们都是由若干个小接口组合而成的。以 <code>io.ReadWriteCloser</code> 接口为例，它是由 <code>io.Reader</code>、<code>io.Writer</code> 和 <code>io.Closer</code> 这三个接口组成的。</p>
<p>这三个接口都只包含了一个方法，是典型的小接口。它们中的每一个都只代表了一种能力，分别是读出、写入和关闭。我们编写这几个小接口的实现类型通常都会很容易。并且，一旦我们同时实现了它们，就等于实现了它们的组合接口 <code>io.ReadWriteCloser</code>。</p>
<p>即使我们只实现了 <code>io.Reader</code> 和 <code>io.Writer</code>，那么也等同于实现了 <code>io.ReadWriter</code> 接口，因为后者就是前两个接口组成的。可以看到，这几个 <code>io</code> 包中的接口共同组成了一个接口矩阵。它们既相互关联又独立存在。</p>
]]></content>
		</item>
		
		<item>
			<title>结构体及其方法</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_struct/</link>
			<pubDate>Wed, 16 Dec 2020 09:10:06 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_struct/</guid>
			<description>结构体类型基础知识 结构体表示的是实实在在的数据结构。一个结构体类型可以包含若干个字段，每个字段通常都需要有确切的名字和类型。 结构体也可以不包</description>
			<content type="html"><![CDATA[<h2 id="结构体类型基础知识">结构体类型基础知识</h2>
<p>结构体表示的是实实在在的数据结构。一个结构体类型可以包含若干个字段，每个字段通常都需要有确切的名字和类型。</p>
<p>结构体也可以不包含任何字段，我们还可以为类型关联上一些方法，这里可以把方法看成是函数的特殊版本。</p>
<p>函数是独立的程序实体。可以声明有名字的函数，也可以声明没名字的函数，还可以把函数当成普通的值传来传去。可以把具有相同签名的函数抽象成独立的函数类型，作为一组输入、输出（或者说一类逻辑组件）的代表。</p>
<p>方法却不同，它需要有名字，不能被当做值来看待，最重要的是，它必须隶属某一个类型。方法所属的类型会通过其声明中的接收者（receiver）声明体现出来。</p>
<p>接收者声明就是关键字 <code>func</code> 和方法名称之间的圆括号包裹起来的内容，其中必须包含确切的名称和类型字面量。</p>
<p>接收者的类型就是当前方法所属的类型，接收者的名称就是在当前方法中引用它所属类型的当前值。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AnimalCategory 代表动物分类学中的基本分类法。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AnimalCategory</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">kingdom</span> <span class="kt">string</span> <span class="c1">// 界。
</span><span class="c1"></span>	<span class="nx">phylum</span>  <span class="kt">string</span> <span class="c1">// 门。
</span><span class="c1"></span>	<span class="nx">class</span>   <span class="kt">string</span> <span class="c1">// 纲。
</span><span class="c1"></span>	<span class="nx">order</span>   <span class="kt">string</span> <span class="c1">// 目。
</span><span class="c1"></span>	<span class="nx">family</span>  <span class="kt">string</span> <span class="c1">// 科。
</span><span class="c1"></span>	<span class="nx">genus</span>   <span class="kt">string</span> <span class="c1">// 属。
</span><span class="c1"></span>	<span class="nx">species</span> <span class="kt">string</span> <span class="c1">// 种。
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="nx">AnimalCategory</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s%s%s%s%s%s%s&#34;</span><span class="p">,</span>
    <span class="nx">ac</span><span class="p">.</span><span class="nx">kingdom</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">phylum</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">class</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">order</span><span class="p">,</span>
    <span class="nx">ac</span><span class="p">.</span><span class="nx">family</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">genus</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">species</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结构体类型 <code>AnimalCategory</code> 代表了动物的基本分类法，其中有 7 个 <code>string</code> 类型的字段，分别表示各个等级的分类。</p>
<p>下边有个名叫 <code>String</code> 的方法，从它的接收者声明可以看出它隶属于 <code>AnimalCategory</code> 类型。</p>
<p>通过该方法的接收者名称 <code>ac</code>，我们可以在其中引用到当前值的任何一个字段，或者调用到当前值的任何一个方法（也包括 <code>String</code> 方法自己）。</p>
<p>这个 <code>String</code> 方法的功能是提供当前值的字符串表示形式，其中的各个等级分类会按照从大到小的顺序排列。使用时，我们可以这样表示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">category</span> <span class="o">:=</span> <span class="nx">AnimalCategory</span><span class="p">{</span><span class="nx">species</span><span class="p">:</span> <span class="s">&#34;cat&#34;</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The animal category: %s\n&#34;</span><span class="p">,</span> <span class="nx">category</span><span class="p">)</span>
</code></pre></div><p>这里，我用字面量初始化了一个 <code>AnimalCategory</code> 类型的值，并把它赋给了变量 <code>category</code>。为了不喧宾夺主，我只为其中的 <code>species</code> 字段指定了字符串值&quot;cat&quot;，该字段代表最末级分类“种”。</p>
<p>在 <code>Go</code> 语言中，我们可以通过为类型编写名为 <code>String</code> 的方法，来自定义该类型的字符串表示形式。这个 <code>String</code> 方法不需要任何参数声明，但需要一个 <code>string</code> 类型的结果声明。</p>
<blockquote>
<p>方法隶属的类型并不局限于结构体类型，但必须是某个自定义的数据类型，而且不能是任何接口类型。</p>
<p>一个数据类型关联的所有方法，共同组成了该类型的方法集合。同一个方法集合中的方法不能出现重名。如果它们所属的数据类型是结构体，那面它们的名称和该类型中的任何字段也不能重名。</p>
<p>结构体的字段是它的一个属性或者一项数据，隶属它的方法是附加在其数据上的一项操作或者能力。将属性及其能力封装在一起是面向对象的一个主要原则。</p>
<p><code>Go</code> 语言摄取了面向对象编程中的很多优秀特性，同时也推荐这种封装的做法。从这方面看，<code>Go</code> 语言是支持面向对象编程的，但它选择摒弃了一些在实际运用过程中容易引起程序开发者困惑的特性和规则。</p>
</blockquote>
<h2 id="结构体类型的嵌套">结构体类型的嵌套</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Animal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">scientificName</span> <span class="kt">string</span> <span class="c1">// 学名。
</span><span class="c1"></span>	<span class="nx">AnimalCategory</span>        <span class="c1">// 动物基本分类。
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><code>Go</code> 语言规范规定，如果一个字段的声明中只有字段类型名而没有字段名称，那么它就是一个嵌入字段，也被称为匿名字段。可以通过此类型变量名跟 <code>.</code>，再跟嵌入字段类型的方式引用到该字段，也就是说，嵌入字段的类型既是类型也是名称。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">Animal</span><span class="p">)</span> <span class="nf">Category</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nx">AnimalCategory</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>在某个代表变量的标识符右边加 <code>.</code>，再加上字段名或方法名的表达式被称为选择表达式，它用来表示选择了该变量的某个字段或方法。</p>
<p>嵌入字段的方法集合会被无条件的合并进被嵌入类型的方法集合中：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">animal</span> <span class="o">:=</span> <span class="nx">Animal</span><span class="p">{</span>
    <span class="nx">scientificName</span><span class="p">:</span> <span class="s">&#34;American Shorthair&#34;</span><span class="p">,</span>
    <span class="nx">AnimalCategory</span><span class="p">:</span> <span class="nx">category</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The animal: %s\n&#34;</span><span class="p">,</span> <span class="nx">animal</span><span class="p">)</span>
</code></pre></div><p>这里并没有给 <code>Animal</code> 编写 <code>String</code> 方法，但是是没问题的，嵌入字段 <code>AnimalCategory</code> 的 <code>String</code> 方法会被当做 <code>animal</code> 的方法调用。</p>
<h2 id="嵌入类型和被嵌入类型方法重名会怎样">嵌入类型和被嵌入类型方法重名会怎样</h2>
<p>嵌入类型相当于父类，被嵌入类型相当于子类，当双方有方法重名时，子类方法覆盖父类方法，就是说嵌入类型的方法会被屏蔽。</p>
<p>不论这两个方法的签名是否相同，只要名称一样，被嵌入类型的方法都会屏蔽掉嵌入类型的方法。</p>
<p>类似的，我们同样可以像访问被嵌入类型的字段那样直接访问嵌入类型的字段，所以如果这两个结构体类型里存在同名字段，那么嵌入类型中的字段一定会被屏蔽。</p>
<p>正因为嵌入类型的字段和方法都会集合到被嵌入类型上，所以即使两个类型的成员一个是字段，一个是方法，也会有这种屏蔽现象。</p>
<p>不过即使被屏蔽了，我们仍然可以通过链式的选择表达式，选择到嵌入类型的字段或方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">Animal</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s (category: %s)&#34;</span><span class="p">,</span>
		<span class="nx">a</span><span class="p">.</span><span class="nx">scientificName</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">AnimalCategory</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在这里，我们把对嵌入类型的 <code>String</code> 方法的调用结果融入到了 <code>Animal</code> 类型的同名方法的结果中。</p>
<p><p class="md__image">
  <img src=".././image/471b42767d0c82af8acd22c13dfd33b2.png"
    alt=""  />
</p>
</p>
<h2 id="多层嵌入的问题">多层嵌入的问题</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Cat</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
	<span class="nx">Animal</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cat</span> <span class="nx">Cat</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s (category: %s, name: %q)&#34;</span><span class="p">,</span>
		<span class="nx">cat</span><span class="p">.</span><span class="nx">scientificName</span><span class="p">,</span> <span class="nx">cat</span><span class="p">.</span><span class="nx">Animal</span><span class="p">.</span><span class="nx">AnimalCategory</span><span class="p">,</span> <span class="nx">cat</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>嵌入字段本身也有嵌入字段，这种情况下的屏蔽现象会以嵌入字段的层级为依据，层级越深的字段或方法越可能被屏蔽。</p>
<p>处于同一级别的多个嵌入字段拥有相同的字段或方法，会依次执行。</p>
<h2 id="go-语言是用嵌入字段实现了继承吗"><code>Go</code> 语言是用嵌入字段实现了继承吗</h2>
<p><code>Go</code> 语言中没有继承的概念，只是通过嵌入字段的方式实现了类型之间的组合。</p>
<p>简单来说，面向对象编程中的集成，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的。</p>
<p>类型之间的组合采用的是非声明的方式，我们不需要显示的声明某个类型实现了某个接口，或一个类型继承了另一个类型。同时，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。</p>
<p>我们要做的只是把类型当做字段嵌入进来，然后坐享其成的使用嵌入字段所拥有的一切。如果嵌入字段哪里不合心意，还可以用屏蔽的方式来调整和优化。</p>
<p>类型组合要比继承更加简洁和清晰，<code>Go</code> 语言可以轻而易举地通过嵌入多个字段来实现功能强大的类型，却不会有多重继承那样复杂的层次结构和可观的管理成本。</p>
<h2 id="值方法和指针方法都是什么意思有什么区别">值方法和指针方法都是什么意思，有什么区别</h2>
<p>所谓的值方法，就是接收者类型是非指针的自定义类型的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cat</span> <span class="o">*</span><span class="nx">Cat</span><span class="p">)</span> <span class="nf">SetName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">cat</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="nx">name</span>
<span class="p">}</span>
</code></pre></div><p>所谓的指针方法，就是接收者类型是上述指针类型的方法。</p>
<p>它们之间有如下几点不同：</p>
<ul>
<li>值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修改一般不会体现在原值上，除非这个类型本身是某个引用类型（切片或字典）的别名类型。而指针方法的接收者，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内对该副本指向的值进行修改，一定会体现在原值上。</li>
<li>一个自定义数据类型的方法集合中仅包含它所有的值方法，而该类型的指针方法却包含了所有的值方法和指针方法。严格来讲，我们在这样的基本类型值上只能调用它的值方法，但是，<code>Go</code> 语言会适时的为我们进行自动转译，使得我们在值上也能调用它的指针方法。即：先取它的指针值，然后在指针上调用指针方法。</li>
<li>一个类型的方法集合中有哪些方法与它能实现哪些接口类型是相关的。如果一个基本类型和它的指针类型的方法集合不同，那么它具体实现的接口类型的数量也会有差异，除非这两个都是零。如，一个指针类型实现了某个接口类型，但它的基本类型却不一定能够作为该接口的实现类型。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>函数的正确使用姿势</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_func/</link>
			<pubDate>Tue, 15 Dec 2020 10:08:40 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_func/</guid>
			<description>函数是一等公民 在 Go 语言中，函数可是一等的（first-class）公民，函数类型也是一等的数据类型。 简单来说，这意味着函数不但可以用于封装代</description>
			<content type="html"><![CDATA[<h2 id="函数是一等公民">函数是一等公民</h2>
<p>在 <code>Go</code> 语言中，函数可是一等的（first-class）公民，函数类型也是一等的数据类型。</p>
<p>简单来说，这意味着函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通的值，在其他函数间传递、赋予变量、做类型判断和转换等等，就像切片和字典的值那样。</p>
<p>更深层次来说，函数值可以由此成为能够被随意传播的独立逻辑组件（或者说功能模块）。</p>
<p>对于函数类型来说，它是一种对一组输入、输出进行模板化的重要工具，它比接口类型更加轻巧、灵活，它的值也借此变成了可被热替换的逻辑组件。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">Printer</span> <span class="kd">func</span><span class="p">(</span><span class="nx">contents</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">printToStd</span><span class="p">(</span><span class="nx">contents</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">bytesNum</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Printer</span>
	<span class="nx">p</span> <span class="p">=</span> <span class="nx">printToStd</span>
	<span class="nf">p</span><span class="p">(</span><span class="s">&#34;something&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这里我们声明了一个函数类型 <code>Printer</code>，在类型声明的名称右边的是 <code>func</code> 关键字，由此可知是一个函数类型声明。</p>
<p><code>func</code> 右边是函数类型的参数列表和结果列表。其中，参数列表必须用圆括号包裹，而只要结果列表中只有一个结果声明，并且没有为它命名，那么可以省略外面的圆括号。</p>
<p>函数签名的方式与函数声明是一致的。只是紧挨在参数列表左边的不是函数名称，而是关键字 <code>func</code>。这里函数名称和 <code>func</code> 互换了位置。</p>
<blockquote>
<p>函数签名其实就是函数的参数列表和结果列表的统称，它定义了可用来鉴别不同函数的那些特征，同时也定义了我们与函数交互的方式。</p>
</blockquote>
<p>注意，各个参数和结果的名称不能算作函数签名的一部分，甚至对结果声明来说，没有名称都可以。</p>
<p>只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，我们就可以说它们是一样的函数，或者说是实现了同一个函数类型的函数。</p>
<p>严格来说，函数的名称也不能算作函数签名的一部分，它只是我们在调用函数时需要给定的标识符而已。</p>
<p>我们下面声明的 <code>printToStd</code> 的签名和 <code>Printer</code> 是一致的，因此前者是后者的一个实现，即使他们的名称以及有的结果名称是不一样的。</p>
<p>通过 <code>main</code> 函数中的代码，我们就可以证实这两者之间的关系了，我们顺利的把 <code>printToStd</code> 赋给了 <code>Printer</code> 类型的变量 <code>p</code>，并且成功调用了它。</p>
<p>总之，函数是一等公民是函数式编程（functional programming）的重要特征。<code>Go</code> 语言在语言层面支持了函数式编程。</p>
<h2 id="怎样编写高阶函数">怎样编写高阶函数</h2>
<p>简单的说，高阶函数可以满足下面两个条件：</p>
<ul>
<li>接收其他函数作为参数传入。</li>
<li>把其他函数作为结果返回。</li>
</ul>
<p>只要满足其中任意一个特点，我们就可以说这个函数是一个高阶函数。高阶函数也是函数式编程中重要概念和特征。</p>
<p>例如，有需求需要编写 <code>calculate</code> 函数来实现两个整数间的加减乘除计算，但是希望两个整数和具体的操作都由调用方给出。我们来实现它：</p>
<p>首先，声明一个名叫 <code>operate</code> 的函数类型，它有两个参数和一个结果，都是 <code>int</code> 类型的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">operate</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
</code></pre></div><p>然后，我们编写 <code>calculate</code> 函数的签名部分。这个函数除了需要两个 <code>int</code> 参数，还需要一个 <code>operate</code> 类型的参数。</p>
<p>该函数的结果应该有两个，一个 <code>int</code> 类型，代表真正的操作结果，另一个 <code>error</code> 类型的，表示如果 <code>operate</code> 类型的参数为 <code>nil</code>，那么就返回一个错误。</p>
<blockquote>
<p>函数类型属于引用类型，它的值可以为 <code>nil</code>，并且它的零值就是 <code>nil</code>。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">calculate</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">op</span> <span class="nx">operate</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">op</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;无效操作&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">op</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p><code>calculate</code> 函数的实现比较简单，先用卫述语句检查一下参数，如果 <code>operate</code> 类型的参数 <code>op</code> 为 <code>nil</code>，就直接返回 0 和一个错误。</p>
<blockquote>
<p>卫述语句是指被用来检查关键的先决条件的合法性，并在检查未通过的情况下立即终止当前代码块的执行。<code>Go</code> 语言中，<code>if</code> 通常被作为卫述语句。</p>
</blockquote>
<p>如果检查无误，那么调用 <code>op</code> 并把那两个操作数传给它，最后返回 <code>op</code> 的结果和表示没有错误发生的 <code>nil</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">op</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">calculate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">op</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>上面这个例子展示了：把函数作为一个普通的值赋给一个变量；让函数在其他函数间传递。</p>
<p>那么 <code>calculate</code> 函数就是一个高阶函数，该函数接受其他函数作为参数传入。</p>
<p>第二个特点：把其他函数作为返回结果。可见以下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">operates</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>

<span class="kd">type</span> <span class="nx">calculator</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">genCalculator</span><span class="p">(</span><span class="nx">op</span> <span class="nx">operates</span><span class="p">)</span> <span class="nx">calculator</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">op</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;无效操作&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nf">op</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">),</span> <span class="kc">nil</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">op</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
	<span class="p">}</span>

	<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">78</span>
	<span class="nx">add</span> <span class="o">:=</span> <span class="nf">genCalculator</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span>
	<span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The result: %d (error: %v)\n&#34;</span><span class="p">,</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="如何实现闭包">如何实现闭包</h2>
<p>什么是闭包，在一个函数中存在对外来标识符的引用，这个外来标识符既不代表当前函数的任何参数或结果，也不是函数内部声明的，它是从外部直接拿过来的。</p>
<p>还有专门的术语称呼它，自由变量，可见它代表的肯定是个变量。实际上，如果它是个常量，那也就形成不了闭包了，因为常量是不可变的程序实体，而闭包体现的却是由不确定变为确定的一个过程。</p>
<p>闭包函数就是因为引用了自由变量，而呈现出一种不确定的状态，也叫开放状态。也就是说，它的内部逻辑是不完整的，有一部分逻辑需要自由变量参与完成，而自由变量到底代表了什么在闭包函数被定义的时候是不确定的。</p>
<p>即使对于像 <code>Go</code> 语言这种静态语言，在定义闭包函数时也只能知道自由变量的类型。</p>
<p>上面那个例子中提到的 <code>genCalculator</code> 函数内部就实现了闭包函数，该函数也是高阶函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">genCalculator</span><span class="p">(</span><span class="nx">op</span> <span class="nx">operates</span><span class="p">)</span> <span class="nx">calculator</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">op</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;无效操作&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nf">op</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">),</span> <span class="kc">nil</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>genCalculator</code> 函数只做了一件事，定义了一个匿名的、<code>calculator</code> 类型的函数并把它返回。</p>
<p>这个匿名函数就是一个闭包函数。它里面使用的 <code>op</code> 既不代表它的任何参数或结果也不是它自己声明的，而是外层函数的参数，对它来说是自由变量。</p>
<p>这个自由变量代表了什么，定义闭包函数时是不确定的，定义外层函数时才能确定。</p>
<p><p class="md__image">
  <img src=".././image/61f3689a0023e83407ccae081cdd8108.png"
    alt=""  />
</p>
</p>
<p>表面上看，我们只是延迟实现了一部分程序逻辑或功能，但实际上我们是在动态的生成那部分程序逻辑。我们可以借此在程序运行的过程中，根据需要生成功能不同的函数，继而影响后续的程序行为。</p>
<h2 id="传入函数中的那些参数值后来怎样了">传入函数中的那些参数值后来怎样了</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">array1</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The array: %v\n&#34;</span><span class="p">,</span> <span class="nx">array1</span><span class="p">)</span>
  <span class="nx">array2</span> <span class="o">:=</span> <span class="nf">modifyArray</span><span class="p">(</span><span class="nx">array1</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The modified array: %v\n&#34;</span><span class="p">,</span> <span class="nx">array2</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The original array: %v\n&#34;</span><span class="p">,</span> <span class="nx">array1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modifyArray</span><span class="p">(</span><span class="nx">a</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;x&#34;</span>
  <span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</code></pre></div><p>所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，而是它们的副本。</p>
<p>数组是值类型，每一次复制都会拷贝它以及所有的元素值。而对于切片、字典、通道等引用类型，只会复制它们本身，并不会复制它们的底层数据，也就是浅复制。</p>
<p>以切片值为例，复制的时候只是拷贝了它指向底层数组中某一个元素的指针，以及它的容量和长度，它底层的数组不会被拷贝。</p>
<p>需要注意得是，当传入函数的是一个值类型的参数值，但这个参数值中的某个元素是引用类型的，仍然符合上面的规则。如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">array1</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">][]</span><span class="kt">string</span><span class="p">{</span>
    <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;d&#34;</span><span class="p">,</span> <span class="s">&#34;e&#34;</span><span class="p">,</span> <span class="s">&#34;f&#34;</span><span class="p">},</span>
    <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;g&#34;</span><span class="p">,</span> <span class="s">&#34;h&#34;</span><span class="p">,</span> <span class="s">&#34;i&#34;</span><span class="p">},</span>
    <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;j&#34;</span><span class="p">,</span> <span class="s">&#34;k&#34;</span><span class="p">,</span> <span class="s">&#34;l&#34;</span><span class="p">},</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modifyArray</span><span class="p">(</span><span class="nx">a</span> <span class="p">[</span><span class="mi">3</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">][]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;z&#34;</span>
	<span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</code></pre></div><p>上面例子中，对 <code>a[1]</code> 的整个元素替换是不会影响原来的数组的，但是对 <code>a[0][1]</code> 的替换是会影响到原始数据的。</p>
<p>相关原则：既不要把你的程序细节暴露给外界，也尽量不要让外界的变动影响到你的程序。</p>
]]></content>
		</item>
		
		<item>
			<title>通道的高级玩法</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_channel2/</link>
			<pubDate>Mon, 14 Dec 2020 15:14:51 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_channel2/</guid>
			<description>单向通道 我们通常说通道都是指双向通道，即：即可以发也可以收的通道。 所谓单向通道就是 只能发不能收 或者 只能收不能发 的通道。一个通道是单向还是双向</description>
			<content type="html"><![CDATA[<h2 id="单向通道">单向通道</h2>
<p>我们通常说通道都是指双向通道，即：即可以发也可以收的通道。</p>
<p>所谓单向通道就是 只能发不能收 或者 只能收不能发 的通道。一个通道是单向还是双向的由它的字面量体现。</p>
<p>接收操作符 <code>&lt;-</code> 如果用在通道的类型字面量中，它代表的就不再是接收或者发送的动作了，而是通道的方向。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span><span class="c1">//发送通道，只能发不能收
</span><span class="c1"></span><span class="nb">make</span><span class="p">(</span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span><span class="c1">//接收通道，只能收不能发
</span></code></pre></div><h3 id="单向通道的应用价值">单向通道的应用价值</h3>
<p>概括的说，单向通道最主要的用途就是约束其他代码的行为。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SendInt</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
	<span class="c1">//fmt.Printf(&#34;element of channel: %v.\n&#34;, &lt;- ch)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>上面这段代码声明了一个函数，只接受一个发送通道，那么函数中就只能像通道发送元素值而不能从通道接收元素值。这就起到了约束函数行为的作用。</p>
<p>如果是接口类型中声明的某个函数的定义使用了单向通道，那么等于该接口类型的所有实现都受到了约束。</p>
<p>我们在调用的这个函数的时候，只需要把一个元素类型匹配的双向通道传给它，<code>Go</code> 会自动把通道转成函数需要的单向通道。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch3</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">SendInt</span><span class="p">(</span><span class="nx">ch3</span><span class="p">)</span>
<span class="nx">elmt3</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">ch3</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;elemt3 is %v. channel stats is %v.\n&#34;</span><span class="p">,</span> <span class="nx">elmt3</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>

<span class="c1">//elemt3 is 81. channel stats is true.
</span></code></pre></div><p>我们还可以在函数声明的结果列表中使用单向通道，如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getIntChan</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">num</span> <span class="o">:=</span> <span class="mi">5</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span>
	<span class="p">}</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ch</span>
<span class="p">}</span>
</code></pre></div><p>函数返回一个接收通道，这以为这得到该通道的程序只能从通道中读取数据。这实际上也是对函数调用方的一种约束。</p>
<p><code>Go</code> 语言中还可以声明函数类型，如果在函数类型中使用了单向通道，那么等于约束了所有实现了这个函数类型的函数。</p>
<p>看下函数调用结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch4</span> <span class="o">:=</span> <span class="nf">getIntChan</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">elemt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch4</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the element in ch4: %v.\n&#34;</span><span class="p">,</span> <span class="nx">elemt</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><code>for</code> 语句会不断的尝试从通道 <code>ch4</code> 中读取元素值。即使通道被关闭了，它也会取出所有剩余元素值后再结束运行。</p>
<p>通常通道里没有元素值时，<code>for</code> 语句会阻塞在这里直到有新的元素值可取。但这里因为函数里把通道关闭了，所以取出通道内的所有元素值后会结束运行。</p>
<p>如果通道的值为 <code>nil</code>，那么 <code>for</code> 语句就永远阻塞在这里。</p>
<h2 id="select-和通道是怎样连用"><code>select</code> 和通道是怎样连用</h2>
<p><code>select</code> 和 <code>switch</code> 用法差不多，但是只能和通道联用，每个 <code>case</code> 都只能包含通道表达式。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 准备好几个通道。
</span><span class="c1"></span><span class="nx">intChannels</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">{</span>
    <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">}</span>
<span class="c1">// 随机选择一个通道，并向它发送元素值。
</span><span class="c1"></span><span class="nx">index</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The index: %d\n&#34;</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span>
<span class="nx">intChannels</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="nx">index</span>
<span class="c1">// 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。
</span><span class="c1"></span><span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">intChannels</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;The first candidate case is selected.&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">intChannels</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;The second candidate case is selected.&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">elem</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">intChannels</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The third candidate case is selected, the element is %d.\n&#34;</span><span class="p">,</span> <span class="nx">elem</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;No candidate case is selected!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>首先声明了一个 3 个元素的通道数组，每个元素都是 <code>int</code> 类型，容量为 1 的双向通道。然后随机生成一个范围在 0,2 的整数，把它作为索引从上面的数组中选择一个通道并像其中发送一个元素值。最后用 <code>select</code> 分别尝试从数组中的 3 个通道中接收元素值，哪一个通道有值，则执行对应的分支。如果都没有的话则执行默认分支。</p>
<p>使用 <code>select</code> 时，应注意以下几点：</p>
<ul>
<li>如果使用了默认分支，那么无论涉及通道的操作是否阻塞，<code>select</code> 语句都不会阻塞。因为如果没有满足求职条件的话，就会执行默认分支。</li>
<li>如果没有使用默认分支，那么当所有 <code>case</code> 分支都不满足求职条件的话，<code>select</code> 语句就会被阻塞，直到有一个 <code>case</code> 表达式满足条件。</li>
<li>我们需要通过第二个结果值来判断通道是否已经关闭，如果关闭了，就应该及时屏蔽掉对应分支或者采取其他措施。这对于程序逻辑和程序性能是有好处的。</li>
<li><code>select</code> 语句只能对其中的每一个 <code>case</code> 表达式各求值一次，如果想连续或定时操作其中的通道的话，通常需要通过 <code>for</code> 语句中嵌套 <code>select</code> 的方式实现。这时需要注意，在 <code>select</code> 中使用 <code>break</code> 只能结束当前的 <code>select</code> 语句执行，并不会对外层的 <code>for</code> 产生作用。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">intChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">// 一秒后关闭通道。
</span><span class="c1"></span><span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">intChan</span><span class="p">)</span>
<span class="p">})</span>
<span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">intChan</span><span class="p">:</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;The candidate case is closed.&#34;</span><span class="p">)</span>
    <span class="k">break</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;The candidate case is selected.&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="select-语句的分支选择规则"><code>select</code> 语句的分支选择规则</h2>
<ul>
<li>对于每一个 <code>case</code> 表达式，都至少会包含一个代表发送或者接受的表达式。同时也可能包含其他表达式。</li>
<li><code>select</code> 语句包含的候选分支中的 <code>case</code> 表达式都会在该语句执行开始时先被求值。并且求值顺序是从上到下的。</li>
<li>对每一个 <code>case</code> 表达式求值时，如果相应的操作正处于阻塞状态，那么这个 <code>case</code> 表达式所在的候选分支是不满足条件的。</li>
<li>一个候选分支中的所有 <code>case</code> 表达式都被求值完毕后，才会继续下一个候选分支。当所有候选分支都不满足条件时，会执行默认分支。如果没有默认分支，<code>select</code> 会阻塞，直到有满足条件的候选分支。</li>
<li>如果有多个候选分支满足条件，<code>select</code> 会用一种伪随机的算法在其中选择一个执行。</li>
<li>一条 <code>select</code> 语句只能有一个默认分支，并且默认分支只能在无候选分支可选时才会被执行。</li>
<li><code>select</code> 语句的每次执行，包括 <code>case</code> 表达式求值和分支选择，都是独立的。至于它们执行是否是并发安全的，需要看其中是否有包含并发不安全的代码。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>通道的基本操作</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_channel/</link>
			<pubDate>Sun, 13 Dec 2020 15:17:24 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_channel/</guid>
			<description>作为 Go 语言最具特色的数据类型，通道（channel）完全可以与 goroutine （协程）并驾齐驱，共同代表 Go 语言独有的并发编程模式和编程哲学。 Don’t communicate by</description>
			<content type="html"><![CDATA[<p>作为 <code>Go</code> 语言最具特色的数据类型，通道（channel）完全可以与 <code>goroutine</code> （协程）并驾齐驱，共同代表 <code>Go</code> 语言独有的并发编程模式和编程哲学。</p>
<blockquote>
<p>Don’t communicate by sharing memory; share memory by communicating. （不要通过共享内存来通信，而应该通过通信来共享内存。）</p>
</blockquote>
<p>这是作为 <code>Go</code> 语言的主要创造者之一的 <code>Rob Pike</code> 的至理名言，这也充分体现了 <code>Go</code> 语言最重要的编程理念。而通道类型恰恰是后半句话的完美实现，我们可以利用通道在多个 <code>goroutine</code> 之间传递数据。</p>
<h2 id="通道的基础知识">通道的基础知识</h2>
<p>通道类型的值本身就是并发安全的，这也是 <code>Go</code> 语言自带的、唯一一个可以满足并发安全性的类型。</p>
<p>声明一个通道时，需要用到内建函数 <code>make</code>。就像用 <code>make</code>  初始化切片那样，传给这个函数的第一个参数应该是代表了通道的具体类型的类型字面量。第二个参数确定该通道的元素类型，这决定了我们可以通过这个通道传递什么类型的数据。</p>
<p>比如，类型字面量 <code>chan int</code>，其中 <code>chan</code> 是表示通道的关键字，<code>int</code> 则说明该通道的元素类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></div><p>声明通道时还可以传一个 <code>int</code> 类型的参数表示通道的容量。该参数是可选的，表示通道可以缓存多少个元素值，因此该参数不能小于 0。</p>
<p>当容量为 0 时，是非缓冲通道。容量大于 0 时，是缓冲通道。</p>
<p>一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的元素值都是严格的按照发送的顺序排列的，先被发送通道的元素值一定先被接收。元素值的发送和接收都需要用到操作符 <code>&lt;-</code>。也可以叫它接送操作符。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">2</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">3</span>
	<span class="nx">elmt</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">ch</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the first element is: %v.\n&#34;</span><span class="p">,</span> <span class="nx">elmt</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>上面这段代码中，我们声明并初始化了一个 <code>int</code> 类型，容量是 3 的通道 <code>ch</code>，并且往通道里发送了 3 个值 2、1、3。</p>
<p>由于该通道的容量是 3，所以在通道里面不包含任何元素的时候，可以连续的像该通道发送 3 个值，此时这三个值都将被缓存到通道中。</p>
<p>然后我们使用短声明方式声明了变量 <code>elmt</code> 接收通道里的第一个元素值，并把它打印出来。</p>
<h2 id="对通道的发送和接收操作有哪些特性">对通道的发送和接收操作有哪些特性</h2>
<p>基本特性如下：</p>
<ul>
<li>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。</li>
<li>发送操作和接收操作中对元素值的处理都是不可分割的。</li>
<li>发送操作在完全完成之前会被阻塞。接收操作也是如此。</li>
</ul>
<h3 id="第一个基本特性">第一个基本特性</h3>
<p>在同一个时刻，<code>Go</code> 语言的运行时系统只会执行同一个通道的任意个发送操作中的某一个。直到这个元素值被完全复制进通道之后，其他针对该通道的发送操作才可能被执行。</p>
<p>类似的，同一时刻运行时系统也只会执行同一个通道的任意个接收操作中的某一个。知道这个元素值被完全移出通道之后，其他针对该通道的接收操作才可能被执行。即使这些操作是并发执行的也是如此。</p>
<p>这里所谓的并发执行，可以认为是多个代码块分别在不同的 <code>goroutine</code> 之中，并有机会在同一个时间段被执行。</p>
<p>另外，对于通道中的同一个元素值来说，发送操作和接收操作也是互斥的。如，正在被复制进通道但还未完成的元素值，绝对不会被想接收它的一方看到和取走。</p>
<p>元素值从外界进入通道时会被复制。更具体的说，进入通道的并不是在接收操作符右面的那个元素值，而是它的副本。</p>
<p>另一方面，元素值从通道进入外界时会被移动，第一步是生成元素值的副本准备给接收方，第二步是删除通道中的这个元素值。</p>
<h3 id="第二个基本特征">第二个基本特征</h3>
<p>通道的发送和接收都是原子性的，绝不会被打断。如，发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现值复制了一部分的情况。又如，接收操作在准备好元素副本后，一定会删除通道中的元素值，绝不会出现通道中还有残留的情况。</p>
<p>这既是为了保证通道中元素值的完整性，也是为了保证通道操作的唯一性。通道中的同一元素值只可能是一个发送操作放入的，也只可能是被一个接收操作取出。</p>
<h3 id="第三个基本特征">第三个基本特征</h3>
<p>一般情况下发送操作包含复制元素副本和把副本放到通道这两个步骤。在这两步完全完成之前，发起发送操作的程序会阻塞直到阻塞解除。</p>
<p>更细致的说，在通道完成发送操作之后，运行时系统会通知这段程序所在的 <code>goroutine</code> 继续执行后面的代码。</p>
<p>接收操作通常包含复制元素副本，把副本交给接收方和删除元素值三个步骤，在这三步完全完成之前，发起该操作的程序也会阻塞直到该程序所在的 <code>goroutine</code> 收到运行时系统的通知重新获得运行机会。</p>
<p>所以，阻塞程序就是为了实现操作的互斥和元素值的完整。</p>
<h3 id="发送操作和接收操作什么时候可能被长时间阻塞">发送操作和接收操作什么时候可能被长时间阻塞</h3>
<p>对缓冲通道来说，如果通道已满，那么它的发送操作会被阻塞，直到通道中有元素值被取走。然后通道会优先通知最早因此等待发送的 <code>goroutine</code> 继续执行操作。发送操作被阻塞后，后续操作会顺序进入通道内部的发送等待队列，所以通知的顺序总是公平的。</p>
<p>相对的，如果通道已空，那么它的接收操作会被阻塞，直到通道中有新的元素值出现。这时通道会优先通知最早等待的那个 <code>goroutine</code> 继续执行操作。接收操作阻塞后，后续操作会顺序进入通道内部的接收等待队列。</p>
<p>对非缓冲通道来说，无论是发送还是接收，一开始执行就会被阻塞，知道配对的操作也开始执行，才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。</p>
<p>并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。相比之下，缓冲通道则在用异步的方式传递数据。</p>
<p>大多数情况下，缓冲通道会作为收发双方的中间件。但是，当发送操作执行的时候发现空的通道中正好有等待的接收操作，那么它会直接把元素值复制给接收方。</p>
<p>对于值为 <code>nil</code> 的通道，不论它的具体类型是什么，对它的发送和接收都会永久的处于阻塞状态。通道是引用类型，它的零值就是 <code>nil</code>，所以声明通道时一定要初始化。</p>
<h3 id="发送操作和接收操作什么时候会引发-panic">发送操作和接收操作什么时候会引发 <code>panic</code></h3>
<p>对一个已经关闭了的通道执行收发操作就会引发 <code>panic</code>。</p>
<p>试图关闭一个已经关闭了的通道也会引发 <code>panic</code>。</p>
<p>具体的说，当我们把接收表达式的结果同时赋个两个变量，第二个变量就是 <code>bool</code> 类型。它为 <code>false</code> 的时候表示通道已经关闭，并且再没有元素可取了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">elmt</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">ch</span>
</code></pre></div><p>如果通道关闭时里面还有元素未取出，那么接收表达式的结果仍然会取出元素值并且第二个结果是 <code>true</code>。所以，要通过第二个结果来判断通道是否已关闭可能是有延时的。</p>
<p>通道所有权问题，简单来说，谁创建，谁关闭。</p>
]]></content>
		</item>
		
		<item>
			<title>字典的操作和约束</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_map/</link>
			<pubDate>Sat, 12 Dec 2020 11:33:51 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_map/</guid>
			<description>Go 语言的字典（map）类型 字典存储的不再是单一值，而是键值对的集合。 字典的键类型会受到约束 Go 语言的字典类型其实是一个哈希表（hash tabl</description>
			<content type="html"><![CDATA[<h2 id="go-语言的字典map类型"><code>Go</code> 语言的字典（<code>map</code>）类型</h2>
<p>字典存储的不再是单一值，而是键值对的集合。</p>
<h3 id="字典的键类型会受到约束">字典的键类型会受到约束</h3>
<p><code>Go</code> 语言的字典类型其实是一个哈希表（hash table）的特定实现，其中键和元素最大的不同在于，键的类型是受限的，元素可以是任意类型。</p>
<p>要探究原因，就需要了解哈希表中最重要的过程：映射。</p>
<p>可以把键看成元素的索引，我们可以在哈希表中通过索引找到与它成对的那个元素。</p>
<p>键和元素的这种关系在数学里就被称为“映射”，也是 <code>map</code> 这个词的本意，哈希表的映射过程就存在于对键-元素对的增、删、改、查的操作之中。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">aMap</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="s">&#34;one&#34;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
		<span class="s">&#34;two&#34;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span>
		<span class="s">&#34;three&#34;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">k</span> <span class="o">:=</span> <span class="s">&#34;two&#34;</span>
	<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">aMap</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the element of key %q: %d.\n&#34;</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;not found!&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>我们要在哈希表中查找与某个键值对应的元素值，就要先把键值作为参数传给哈希表。</p>
<p>哈希表会用哈希函数（hash function）把键值转换为哈希值。哈希值通常是一个无符号整数。一个哈希表会持有一定量的桶（bucket），也叫哈希桶，这些哈希桶会均匀的存储其所属哈希表收纳的键-元素对。</p>
<p>哈希表会先用这个键的哈希值的低几位去定位一个哈希桶，然后再去这个哈希桶中查找这个键。</p>
<p>因为键-元素对总是被捆绑在一起存储的，所以找到了键，就一定能找到对应的元素值。然后哈希表把对应的元素值作为结果返回。</p>
<p>只要键-元素对存在哈希表中就一定能找到，因为哈希表的增、删、改时的映射过程，都与前文一致。</p>
<p>所以映射过程的第一步就是：把键值转换为哈希值。</p>
<p><code>Go</code> 语言的字典中，每一个键值都是由它的哈希值代表的。字典不会独立存储任何键的值，但会独立存储它们的哈希值。</p>
<h3 id="字典的键类型不能是哪些类型">字典的键类型不能是哪些类型</h3>
<p><code>Go</code> 语言字典的键类型不能是函数类型、字典类型和切片类型。</p>
<p><code>Go</code> 语言规范规定，在键类型的值之间必须可以判等（==，!=）。由于函数类型、字典类型和切片类型的值不支持判等操作，所以这些类型不能作为字典的键。</p>
<p>即使键值是接口类型，键值的实际类型也不能是上述三种类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">bMap</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="kt">int</span><span class="p">{</span>
  <span class="s">&#34;one&#34;</span><span class="p">:</span>    <span class="mi">1</span><span class="p">,</span>
  <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">}:</span> <span class="mi">2</span><span class="p">,</span><span class="c1">//panic: runtime error: hash of unhashable type []int
</span><span class="c1"></span>  <span class="mi">3</span><span class="p">:</span>        <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>这里变量 <code>bMap</code> 的类型是键类型为 <code>interface{}</code>，值类型为 <code>int</code> 的字典类型。声明的时候进行了初始化，使它包含三个键-元素对。其中第二个键值是 <code>[]int{2}</code>，元素值是 2。这样的键值不会让 <code>Go</code> 的编译器报错，从语法上说，这样做是可以的。</p>
<p>但是，当运行这段代码时，<code>Go</code> 语言的运行时（runtime）系统就会发现这里的问题，它会抛出一个 <code>panic</code> 并把根源指向字面量中定义相应的行。</p>
<p>如果键的类型是数组类型，那么该类型的元素类型就不能是函数类型、字典类型和切片类型。</p>
<p>比如，由于类型 <code>[1][]string</code> 的元素类型是 <code>[]string</code>，所以它就不能作为字典类型的键类型。另外，如果键的类型是结构体类型，那么还要保证其中字段的类型的合法性。无论不合法的类型被埋藏得有多深，比如 <code>map[[1][2][3][]string]int</code>，<code>Go</code> 语言编译器都会把它揪出来。</p>
<h3 id="为什么键值需要支持判等操作">为什么键值需要支持判等操作</h3>
<p><code>Go</code> 语言一旦定位到了某个哈希桶，就会试图在桶中查找键值。</p>
<p>首先，每个哈希桶会把自己包含的所有键的哈希值存起来。<code>Go</code> 语言会用被查找键的哈希值与这些哈希值逐个比较，看看是否有相等的。如果一个相等的也没有，说明这个桶中没有要查找的键值，<code>Go</code> 语言就会立刻返回结果。</p>
<p>如果有相等的，那就在用键值本身去对比一次。因为不同键值的哈希值可能是相同的，这就是“哈希碰撞”。</p>
<p>所以，即使哈希值一样，键值也可能不一样。如果键类型的值无法判断，那映射的过程就没办法继续了。只有键的哈希值和键值都相等，才说明找到了匹配的键-元素对。</p>
<h3 id="应该优先考虑哪些类型作为字典的键类型">应该优先考虑哪些类型作为字典的键类型</h3>
<p>从性能角度来看，把键值转换为哈希值以及把要查找的键值与哈希桶中的键值对比，明显是比较重要且耗时的两个操作。所以，求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。</p>
<p>对于所有基本类型、指针类型，以及数组类型、结构体类型和接口类型，<code>Go</code> 语言都有一套算法与之对应。这套算法就包含了哈希和判等。以求哈希的操作为例，宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点类型、复数类型和指针类型来说都是如此。对于字符串类型来说，由于它的宽度不固定，所以要看具体长度，长度越短哈希越快。</p>
<p>类型的宽度是指它单个值需要占用的字节数。如：<code>bool</code>、<code>int8</code> 等类型的字节数是 1，那面它们的宽度就是 1。</p>
<p>类似的，结构体类型的哈希实际就是对它所有字段值求哈希并进行合并，所以关键在于它的各个字段类型以及字段的数量。而接口类型的哈希算法则由值的实际类型决定。</p>
<p>另外这些高级数据类型的值是可变的，那面变化前后的哈希值就会不同，就会代表两个不同的键值。</p>
<h3 id="在值为-nil-的字典上执行读写操作">在值为 <code>nil</code> 的字典上执行读写操作</h3>
<p>由于字典是引用类型，当仅声明而不初始化一个字典的时候，它的值是 <code>nil</code>。</p>
<p>除了添加键-元素对，我们在一个值为 <code>nil</code> 的字典上做任何操作都不会引起错误。只有当试图在一个值为 <code>nil</code> 的字典中添加一个键-元素对的时候，<code>Go</code> 语言的运行时系统会立即抛出一个 <code>panic</code>。</p>
]]></content>
		</item>
		
		<item>
			<title>container包中的那些容器</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_container/</link>
			<pubDate>Fri, 11 Dec 2020 12:23:21 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_container/</guid>
			<description>container/list Go 语言的链表实现在标准库的 container/list 代码包中。该包有两个公开的程序实体：List 和 Element，List 实现了一个双向链表，Element 代表了</description>
			<content type="html"><![CDATA[<h2 id="containerlist">container/list</h2>
<p><code>Go</code> 语言的链表实现在标准库的 <code>container/list</code> 代码包中。该包有两个公开的程序实体：<code>List</code> 和 <code>Element</code>，<code>List</code> 实现了一个双向链表，<code>Element</code> 代表了链表中的元素。</p>
<h3 id="可以把自己生成的-element-类型值传给链表吗">可以把自己生成的 <code>Element</code> 类型值传给链表吗？</h3>
<p>我们在这里用到了 <code>List</code> 的四种方法。</p>
<p><code>MoveBefore</code> 方法和 <code>MoveAfter</code> 方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。</p>
<p><code>MoveToFront</code> 方法和 <code>MoveToBack</code> 方法，分别用于把给定的元素移动到链表的最前端和最后端。</p>
<p>在这些方法中，“给定的元素”都是 <code>Element</code> 类型的，<code>*Element</code> 类型是 <code>Element</code> 类型的指针类型，<code>*Element</code> 的值就是元素的指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">List</span><span class="p">)</span> <span class="nf">MoveBefore</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">mark</span> <span class="o">*</span><span class="nx">Element</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">List</span><span class="p">)</span> <span class="nf">MoveAfter</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">mark</span> <span class="o">*</span><span class="nx">Element</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">List</span><span class="p">)</span> <span class="nf">MoveToFront</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Element</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">List</span><span class="p">)</span> <span class="nf">MoveToBack</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Element</span><span class="p">)</span>
</code></pre></div><p>如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，链表是不会接受的。</p>
<p>这些方法将不会对链表做出任何改动。因为我们自己生成的 <code>Element</code> 值并不在链表中，所以也就谈不上“在链表中移动元素”。</p>
<p>更何况链表不允许我们把自己生成的 <code>Element</code> 值插入其中。</p>
<p>在 <code>List</code> 包含的方法中，用于插入新元素的那些方法都只接受 <code>interface{}</code> 类型的值。这些方法在内部会使用 <code>Element</code> 值，包装接收到的新元素。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// insertValue is a convenience wrapper for insert(&amp;Element{Value: v}, at).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">List</span><span class="p">)</span> <span class="nf">insertValue</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">at</span> <span class="o">*</span><span class="nx">Element</span><span class="p">)</span> <span class="o">*</span><span class="nx">Element</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Element</span><span class="p">{</span><span class="nx">Value</span><span class="p">:</span> <span class="nx">v</span><span class="p">},</span> <span class="nx">at</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这样做正是为了避免直接使用我们自己生成的元素，主要原因是避免链表的内部关联，遭到外界破坏，这对于链表本身以及我们这些使用者来说都是有益的。</p>
<p><code>Front</code> 和 <code>Back</code> 方法分别用于获取链表中最前端和最后端的元素。</p>
<p><code>InsertBefore</code> 和 <code>InsertAfter</code> 方法分别用于在指定的元素之前和之后插入新元素。</p>
<p><code>PushFront</code> 和 <code>PushBack</code> 方法则分别用于在链表的最前端和最后端插入新元素。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">List</span><span class="p">)</span> <span class="nf">Front</span><span class="p">()</span> <span class="o">*</span><span class="nx">Element</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">List</span><span class="p">)</span> <span class="nf">Back</span><span class="p">()</span> <span class="o">*</span><span class="nx">Element</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">List</span><span class="p">)</span> <span class="nf">InsertBefore</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">mark</span> <span class="o">*</span><span class="nx">Element</span><span class="p">)</span> <span class="o">*</span><span class="nx">Element</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">List</span><span class="p">)</span> <span class="nf">InsertAfter</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">mark</span> <span class="o">*</span><span class="nx">Element</span><span class="p">)</span> <span class="o">*</span><span class="nx">Element</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">List</span><span class="p">)</span> <span class="nf">PushFront</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">Element</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">List</span><span class="p">)</span> <span class="nf">PushBack</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">Element</span>
</code></pre></div><p>这些方法都会把一个 <code>Element</code> 值的指针作为结果返回，它们就是链表留给我们的安全“接口”。拿到这些内部元素的指针，我们就可以去调用前面提到的用于移动元素的方法了。</p>
<h3 id="为什么链表可以做到开箱即用">为什么链表可以做到开箱即用</h3>
<p><code>List</code> 和 <code>Element</code> 都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有特定结构，但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予各自类型的零值。</p>
<blockquote>
<p>广义来讲，所谓的零值就是只做了声明，但还未做初始化的变量被给予的缺省值。每个类型的零值都会依据该类型的特性而被设定。</p>
</blockquote>
<p>那么经过语句 <code>var l list.List</code> 声明的变量 <code>l</code> 的值将会是什么呢？这个零值将会是一个长度为 0 的链表。这个链表持有的根元素也将会是一个空壳，其中只会包含缺省的内容。</p>
<p>这样的链表我们可以直接拿来用。这被称为“开箱即用”。<code>Go</code> 语言标准库中很多结构体类型的程序实体都做到了开箱即用。这也是在编写可供别人使用的代码包（或者说程序库）时，我们推荐遵循的最佳实践之一。</p>
<p>关键在于它的“延迟初始化”机制。所谓的延迟初始化，你可以理解为把初始化操作延后，仅在实际需要的时候才进行。延迟初始化的优点在于“延后”，它可以分散初始化操作带来的计算量和存储空间消耗。</p>
<p>例如，如果我们需要集中声明非常多的大容量切片的话，那么那时的 <code>CPU</code> 和内存空间的使用量肯定都会一个激增，并且只有设法让其中的切片及其底层数组被回收，内存使用量才会有所降低。</p>
<p>如果数组是可以被延迟初始化的，那么计算量和存储空间的压力就可以被分散到实际使用它们的时候。这些数组被实际使用的时间越分散，延迟初始化带来的优势就会越明显。</p>
<blockquote>
<p>延迟初始化的缺点恰恰也在于“延后”。你可以想象一下，如果我在调用链表的每个方法的时候，它们都需要先去判断链表是否已经被初始化，那这也会是一个计算量上的浪费。在这些方法被非常频繁地调用的情况下，这种浪费的影响就开始显现了，程序的性能将会降低。</p>
</blockquote>
<p>在这里的链表实现中，一些方法是无需对是否初始化做判断的。比如 <code>Front</code> 方法和 <code>Back</code> 方法，一旦发现链表的长度为 0, 直接返回 <code>nil</code> 就好了。</p>
<p>又比如，在用于删除元素、移动元素，以及一些用于插入元素的方法中，只要判断一下传入的元素中指向所属链表的指针，是否与当前链表的指针相等就可以了。</p>
<p>如果不相等，就一定说明传入的元素不是这个链表中的，后续的操作就不用做了。反之，就一定说明这个链表已经被初始化了。</p>
<p>原因在于，链表的 <code>PushFront</code> 方法、<code>PushBack</code> 方法、<code>PushBackList</code> 方法以及 <code>PushFrontList</code> 方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始化。</p>
<p>而且，我们在向一个空的链表中添加新元素的时候，肯定会调用这四个方法中的一个，这时新元素中指向所属链表的指针，一定会被设定为当前链表的指针。所以，指针相等是链表已经初始化的充分必要条件。</p>
<p><code>List</code> 利用了自身以及 <code>Element</code> 在结构上的特点，巧妙地平衡了延迟初始化的优缺点，使得链表可以开箱即用，并且在性能上可以达到最优。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">l</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">List</span><span class="p">{}</span>
<span class="nx">l</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="nx">l</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="s">&#34;world&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the list is: %v.\n&#34;</span><span class="p">,</span> <span class="nx">l</span><span class="p">)</span>

<span class="k">for</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Front</span><span class="p">();</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the element is: %v.\n&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//the list is: {{0xc0000621b0 0xc0000621e0 &lt;nil&gt; &lt;nil&gt;} 2}.
</span><span class="c1">//the element is: &amp;{0xc0000621e0 0xc000062180 0xc000062180 hello}.
</span><span class="c1">//the element is: &amp;{0xc000062180 0xc0000621b0 0xc000062180 world}.
</span></code></pre></div><h2 id="containerring">container/ring</h2>
<p><code>container/ring</code> 包中的 <code>Ring</code> 类型实现的是一个循环链表，也就是我们俗称的环。其实 <code>List</code> 在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。</p>
<p>所以也可以说，<code>List</code> 的零值是一个只包含了根元素，但不包含任何实际元素值的空链表。</p>
<h3 id="ring与list的区别">Ring与List的区别</h3>
<p>最主要的不同有下面几种：</p>
<ul>
<li><code>Ring</code> 类型的数据结构仅由它自身即可代表，而 <code>List</code> 类型则需要由它以及 <code>Element</code> 类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。</li>
<li>一个 <code>Ring</code> 类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个 <code>List</code> 类型的值则代表了一个完整的链表。这是表示维度上的不同。</li>
<li>在创建并初始化一个 <code>Ring</code> 值的时候，我们可以指定它包含的元素的数量，但是对于一个 <code>List</code> 值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的 <code>New</code> 函数在功能上的不同，也是两个类型在初始化值方面的第一个不同。</li>
<li>仅通过 <code>var r ring.Ring</code> 语句声明的 <code>r</code> 将会是一个长度为 1 的循环链表，而 <code>List</code> 类型的零值则是一个长度为 0 的链表。别忘了 <code>List</code> 中的根元素不会持有实际元素值，因此计算长度时不会包含它。这是两个类型在初始化值方面的第二个不同。</li>
<li><code>Ring</code> 值的 <code>Len</code> 方法的算法复杂度是 O(N) 的，而 <code>List</code> 值的 <code>Len</code> 方法的算法复杂度则是 O(1) 的。这是两者在性能方面最显而易见的差别。</li>
</ul>
<p>其他的不同基本上都是方法方面的了。比如，循环链表也有用于插入、移动或删除元素的方法，不过用起来都显得更抽象一些，等等。</p>
]]></content>
		</item>
		
		<item>
			<title>数组和切片</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_array_slice/</link>
			<pubDate>Thu, 10 Dec 2020 14:50:38 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_array_slice/</guid>
			<description>Go 语言的数组（array）类型和切片（slice）类型 它们的共同点是都属于集合类的类型，都可以用来存储一种类型的值。 不同的是数组的长度是固定</description>
			<content type="html"><![CDATA[<h2 id="go-语言的数组array类型和切片slice类型"><code>Go</code> 语言的数组（array）类型和切片（slice）类型</h2>
<p>它们的共同点是都属于集合类的类型，都可以用来存储一种类型的值。</p>
<p>不同的是数组的长度是固定的，切片是可变长的。</p>
<p>数组的长度是数组类型的一部分，在声明的时候就必须给定，并且之后不能改变。</p>
<p>切片的字面量中只有元素的类型，没有长度。切片的长度可以自动随着元素的数量增长，但不会减少。</p>
<p><p class="md__image">
  <img src=".././image/edb5acaf595673e083cdcf1ea7bb966c.png"
    alt=""  />
</p>
</p>
<p>切片其实是对数组的简单封装，每个切片的底层数据结构中都会有一个数组。数组是切片的底层数组，切片是数组的某个联系片段的引用。</p>
<blockquote>
<p>因此，<code>Go</code> 语言的切片属于引用类型，同属引用类型的还有字典、通道、函数等；<code>Go</code> 语言的数组属于值类型，同属值类型的还有基础数据类型和结构体类型。</p>
<p><code>Go</code> 语言中不存在 传值或传引用的问题，判断传值还是传引用只要看被传递的值的类型就好。传递的值是引用类型，那么就是传引用。传递的值是值类型，那么就是传值。从传递成本上来讲，引用类型的值通常比值类型低很多。</p>
<p>数组和切片都可以使用索引表达式，得到某个元素的值。也可以使用切片表达式，得到一个新的切片。</p>
</blockquote>
<p>通过内建函数 <code>len</code> 可以得到数组和切片的长度，通过内建函数 <code>cap</code> 可以得到他们的容量。</p>
<p>数组的长度永远等于容量，都是不可变的。切片的容量是会变的，并且有规律可循。</p>
<h3 id="怎样估算切片的长度和容量">怎样估算切片的长度和容量</h3>
<p>先来看一段代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the length of s1: %d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s1</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the capacity of s1: %d\n&#34;</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s1</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the value of s1: %d\n&#34;</span><span class="p">,</span> <span class="nx">s1</span><span class="p">)</span>

	<span class="nx">s2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the length of s2: %d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the capacity of s2: %d\n&#34;</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the value of s2: %d\n&#34;</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>使用内建函数 <code>make</code> 声明了一个 <code>[]int</code> 类型的切片 <code>s1</code> ，传给 <code>make</code> 的第二个参数 5 指明了切片的长度。</p>
<p>同样的方式声明了切片 <code>s2</code>，只不过多传了参数 8 指明了切片的容量。</p>
<p>执行 <code>go run main.go</code> 查看结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">the</span> <span class="nx">length</span> <span class="nx">of</span> <span class="nx">s1</span><span class="p">:</span> <span class="mi">5</span>
<span class="nx">the</span> <span class="nx">capacity</span> <span class="nx">of</span> <span class="nx">s1</span><span class="p">:</span> <span class="mi">5</span>
<span class="nx">the</span> <span class="nx">value</span> <span class="nx">of</span> <span class="nx">s1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
<span class="nx">the</span> <span class="nx">length</span> <span class="nx">of</span> <span class="nx">s2</span><span class="p">:</span> <span class="mi">5</span>
<span class="nx">the</span> <span class="nx">capacity</span> <span class="nx">of</span> <span class="nx">s2</span><span class="p">:</span> <span class="mi">8</span>
<span class="nx">the</span> <span class="nx">value</span> <span class="nx">of</span> <span class="nx">s2</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div><p>我们看到，如果不指定切片的容量，那么它就和切片的长度一致。如果指定了切片容量，那么就是指定的大小。</p>
<p>我们前面说过，切片是对底层数组的封装。切片的底层数据结构是数组，而切片也是对数组一段连续片段的引用。</p>
<p>想象一下，有一个窗口，我们可以通过这个窗口看到一个数组，但是不一定能看到所有元素 ，有时候只能看到连续的一部分。</p>
<p>所以这里 <code>s2</code> 的容量代表底层数组的长度是 8。而 <code>s2</code> 本身的长度是 5，那面 <code>s2</code> 的值就是底层数组中的第 1 个元素到第 5 个元素，对应的底层数组索引范围就是 [0，4]。</p>
<p>切片代表的窗口也会被划分为一个个的小格子，每个小格子都对应底层数组的一个元素。</p>
<p>当我们使用 <code>make</code> 函数或切片字面量（如：<code>[]int{1, 2, 3}</code>）初始化一个切片时，切片的第一个元素总是对应底层数组的第一个元素。</p>
<p>当我们通过切片表达式基于某个数组或者切片生成新的切片时，则不一定：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s3</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}</span>
<span class="nx">s4</span> <span class="o">:=</span> <span class="nx">s3</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the length of s4: %d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s4</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the capacity of s4: %d\n&#34;</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s4</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the value of s4: %d\n&#34;</span><span class="p">,</span> <span class="nx">s4</span><span class="p">)</span>
</code></pre></div><p><code>s3</code> 有 8 个元素，长度和容量都是 8。然后我们用切片表达式 <code>s3[3:6]</code> 初始化了切片 <code>s4</code>。</p>
<p>看下结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">the</span> <span class="nx">length</span> <span class="nx">of</span> <span class="nx">s4</span><span class="p">:</span> <span class="mi">3</span>
<span class="nx">the</span> <span class="nx">capacity</span> <span class="nx">of</span> <span class="nx">s4</span><span class="p">:</span> <span class="mi">5</span>
<span class="nx">the</span> <span class="nx">value</span> <span class="nx">of</span> <span class="nx">s4</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span>
</code></pre></div><p>可见，表达式 <code>s3[3:6]</code> 表示从 <code>s3</code> 中可见索引范围为 3 到 5，并不包括 6。</p>
<p>这里的 3 是起始索引，6 是结束索引。所以 <code>s4</code> 的长度就是 6 减去 3，即 3。</p>
<p><p class="md__image">
  <img src=".././image/96e2c7129793ee5e73a574ef8f3ad755.png"
    alt=""  />
</p>
</p>
<p>再来看容量，一个切片的容量可以被看作是透过这个窗口最多可以看到底层数组中元素的个数。</p>
<p>由于 <code>s4</code> 是在 <code>s3</code> 的基础上得来的，所以 <code>s3</code> 可以看作 <code>s4</code> 的底层数组。</p>
<p>又因为，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直到底层数组的末尾。</p>
<p>所以，<code>s4</code> 的容量就是底层数组的长度 8，减去起始索引 3，即 5。</p>
<p>注意，切片是无法向左扩展的，就是说我们永远无法通过 <code>s4</code> 看到 <code>s3</code> 中最左侧的 3 个元素。</p>
<h3 id="怎样估算切片容量的增长">怎样估算切片容量的增长</h3>
<p>当切片无法容纳更多元素时，<code>Go</code> 语言就会想办法扩容。这并不会改变原来的切片，而是生成一个容量更大的切片，然后把原有的元素和新元素一并拷到新切片中。一般情况下，新切片的容量会是原有切片容量的 2 倍。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s6</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The capacity of s6: %d\n&#34;</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s6</span><span class="p">))</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">s6</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s6</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;s6(%d): len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s6</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s6</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">//The capacity of s6: 0
</span><span class="c1">//s6(1): len: 1, cap: 1
</span><span class="c1">//s6(2): len: 2, cap: 2
</span><span class="c1">//s6(3): len: 3, cap: 4
</span><span class="c1">//s6(4): len: 4, cap: 4
</span><span class="c1">//s6(5): len: 5, cap: 8
</span></code></pre></div><p>当原有切片的长度大于或等于 1024 时，<code>Go</code> 语言将会以原容量的 1.25 倍作为新容量的基准。新容量基准会被调整（不断的与 1.25 相乘），直到结果不小于原有长度和要追加的元素数量之和。最终，新容量往往会比新长度大一些，也可能相等。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s7</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The capacity of s7: %d\n&#34;</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s7</span><span class="p">))</span>
<span class="nx">s7e1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s7</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;s7e1: len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s7e1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s7e1</span><span class="p">))</span>
<span class="nx">s7e2</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s7</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;s7e2: len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s7e2</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s7e2</span><span class="p">))</span>
<span class="nx">s7e3</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s7</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">600</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;s7e3: len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s7e3</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s7e3</span><span class="p">))</span>

<span class="c1">//The capacity of s7: 1024
</span><span class="c1">//s7e1: len: 1224, cap: 1280
</span><span class="c1">//s7e2: len: 1424, cap: 1696
</span><span class="c1">//s7e3: len: 1624, cap: 2048
</span></code></pre></div><p>如果一次追加元素过多，导致新长度超过原容量的 2 倍，那么新容量就会以新长度为基准。当然，新容量很多时候会比新容量基准大一些。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s8</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The capacity of s8: %d\n&#34;</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s8</span><span class="p">))</span>
<span class="nx">s8a</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s8</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;s8a: len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s8a</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s8a</span><span class="p">))</span>
<span class="nx">s8b</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s8a</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;s8b: len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s8b</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s8b</span><span class="p">))</span>
<span class="nx">s8c</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s8b</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;s8c: len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s8c</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s8c</span><span class="p">))</span>

<span class="c1">//The capacity of s8: 10
</span><span class="c1">//s8a: len: 21, cap: 22
</span><span class="c1">//s8b: len: 44, cap: 44
</span><span class="c1">//s8c: len: 89, cap: 96
</span></code></pre></div><h3 id="切片的底层数组什么时候被替换">切片的底层数组什么时候被替换</h3>
<p>确切的说，切片的底层数组永远不会被替换。因为扩容的时候会生成新的底层数组，同时也生成了新的切片。</p>
<p>它只是把新的切片作为了新的底层数组的窗口，并没有对原切片和原底层数组做任何改动。</p>
<p>无需扩容时，<code>append</code> 函数返回的是指向原底层数组的原切片，需要扩容时，<code>append</code> 函数返回的是指向新底层数组的新切片。</p>
<p>只要新长度不超过切片的原容量，就不会引起扩容。只会使底层数组中对应的元素被替换掉。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">a1</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;a1: %v (len: %d, cap: %d)\n&#34;</span><span class="p">,</span>
           <span class="nx">a1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">a1</span><span class="p">))</span>
<span class="nx">s9</span> <span class="o">:=</span> <span class="nx">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="c1">//s9[0] = 1
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;s9: %v (len: %d, cap: %d)\n&#34;</span><span class="p">,</span>
           <span class="nx">s9</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s9</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s9</span><span class="p">))</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">s9</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s9</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;s9(%d): %v (len: %d, cap: %d)\n&#34;</span><span class="p">,</span>
             <span class="nx">i</span><span class="p">,</span> <span class="nx">s9</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s9</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s9</span><span class="p">))</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;a1: %v (len: %d, cap: %d)\n&#34;</span><span class="p">,</span>
           <span class="nx">a1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a1</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">a1</span><span class="p">))</span>

<span class="c1">//a1: [1 2 3 4 5 6 7] (len: 7, cap: 7)
</span><span class="c1">//s9: [2 3 4] (len: 3, cap: 6)
</span><span class="c1">//s9(1): [2 3 4 1] (len: 4, cap: 6)
</span><span class="c1">//s9(2): [2 3 4 1 2] (len: 5, cap: 6)
</span><span class="c1">//s9(3): [2 3 4 1 2 3] (len: 6, cap: 6)
</span><span class="c1">//s9(4): [2 3 4 1 2 3 4] (len: 7, cap: 12)
</span><span class="c1">//s9(5): [2 3 4 1 2 3 4 5] (len: 8, cap: 12)
</span><span class="c1">//a1: [1 2 3 4 1 2 3] (len: 7, cap: 7)
</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go 语言中的类型断言那些事儿</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_type_assertion/</link>
			<pubDate>Wed, 09 Dec 2020 16:34:11 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_type_assertion/</guid>
			<description>怎样判断一个变量的类型 先来看一段代码： package main import &amp;#34;fmt&amp;#34; var container = []string{&amp;#34;0&amp;#34;, &amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;} func main() { container := map[int]string{0: &amp;#34;0&amp;#34;, 1: &amp;#34;1&amp;#34;, 2: &amp;#34;2&amp;#34;} fmt.Printf(&amp;#34;the element is %q.\n&amp;#34;, container[1]) } 怎样在打印期中元素之前判断 container 的类型呢，当然是用类</description>
			<content type="html"><![CDATA[<h2 id="怎样判断一个变量的类型">怎样判断一个变量的类型</h2>
<p>先来看一段代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">var</span> <span class="nx">container</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;0&#34;</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">container</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#34;0&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&#34;2&#34;</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;the element is %q.\n&#34;</span><span class="p">,</span> <span class="nx">container</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div><p>怎样在打印期中元素之前判断 <code>container</code> 的类型呢，当然是用类型断言：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="kd">interface</span><span class="p">{}(</span><span class="nx">container</span><span class="p">).([]</span><span class="kt">string</span><span class="p">)</span>
</code></pre></div><p>这是一条赋值语句，赋值符号右边是类型断言表达式。它包括了用来把 <code>container</code> 变量转换为空接口值的 <code>interface{}(container)</code>，以及用于判断前者类型是否是切片类型 <code>[]string</code> 的 <code>.([]string)</code>。</p>
<p>表达式的结果被赋给两个变量，<code>ok</code> 代表类型判断的结果，<code>true</code> 或 <code>false</code>。</p>
<p>如果是 <code>true</code>，被判断的值将会自动转换成 <code>[]string</code> 的值赋给 <code>value</code> 否则会赋给 <code>nil</code>。</p>
<p>这里的 <code>ok</code> 也可以没有，当判断为否时会引发异常。</p>
<p>类型断言的语法表达形式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">x</span><span class="p">.(</span><span class="nx">T</span><span class="p">)</span>
</code></pre></div><p><code>x</code> 代表要被判断的值，这个值必须是接口类型。</p>
<p>所以前面 <code>container</code> 不是接口类型，要先转化一下。如果是接口类型那面可以这样表示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">container</span><span class="p">.([]</span><span class="kt">string</span><span class="p">)</span>
</code></pre></div><p><p class="md__image">
  <img src=".././image/b5f16bf3ad8f416fb151aed8df47a515.png"
    alt=""  />
</p>
</p>
<h3 id="类型转换规则中的坑">类型转换规则中的坑</h3>
<p>首先，对于整数类型值、整数常量之间的类型转化，原则上只要源值在目标类型的可表示范围内就是合法的。</p>
<p>比如，之所以 <code>uint8(255)</code> 可以把无类型的常量 255 转换为 <code>uint8</code> 类型的值，是因为 255 在 [0, 255] 的范围内。</p>
<p>再比如，<code>int16(-255)</code> 转为 <code>int8</code> 类型会变成 1。</p>
<p>因为整数在 <code>Go</code> 语言中是以补码形式存储的，主要是为了简化计算机对整数的运算过程。负数补码就是源码各位求反再加一。</p>
<p><code>int16</code> 类型的值 -255 的补码是 1111111100000001。如果我们把该值转换为 <code>int8</code> 类型的值，那么 <code>Go</code> 语言会把在较高位置（或者说最左边位置）上的 8 位二进制数直接截掉，从而得到 00000001。又由于其最左边一位是 0，表示它是个正整数，以及正整数的补码就等于其原码，所以最后的值就是 1。</p>
<p>注意，当整数值的类型范围由宽变窄时，只需要在补码形式下截掉以定长度的高位二进制。</p>
<p>第二，整数值转字符串时，被转换的整数值应该可以代表一个有效的 <code>Unicode</code> 代码点，否则结果会是 �。</p>
<p>字符 � 的 <code>Unicode</code> 代码点是 <code>U+FFFD</code>，它是 <code>Unicode</code> 标准中定义的 <code>Replacement Character</code>， 专门用来替换未知的、不被认可的一级无法展示的字符。</p>
<p>如 <code>string(-1)</code>，-1 肯定无法代表一个有效的 <code>Unicode</code> 代码点，所以得到的总是 �。</p>
<p>第三，字符串类型与各种切片类型之间的互转。</p>
<p>一个值从 <code>string</code> 类型向 <code>[]byte</code> 类型转换时代表着以 <code>UTF-8</code> 编码的字符串会被拆分成零散、独立的字节。</p>
<p>一个值从 <code>string</code> 类型向 <code>[]rune</code> 类型转换时代表着字符串会被拆分成一个个 <code>Unicode</code> 字符。</p>
<h2 id="什么是类型别名什么是潜在类型">什么是类型别名，什么是潜在类型</h2>
<p><code>Go</code> 语言中可以使用 <code>type</code> 关键字声明自定义的各种类型。其中有一种 别名类型 的类型。我们可以这样声明：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MyString</span> <span class="p">=</span> <span class="kt">string</span>
</code></pre></div><p>这表明 <code>MyString</code> 是 <code>string</code> 类型的别名类型。别名类型和源类型只是名称不同，其他完全相同。</p>
<p><code>Go</code> 语言内建的基本类型中就存在两个别名类型。<code>byte</code> 是 <code>uint8</code> 的别名类型，而 <code>rune</code> 是 <code>int32</code> 的别名类型。</p>
<p>注意，如果像这样声明：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MyString</span> <span class="kt">string</span>
</code></pre></div><p><code>MyString</code> 和 <code>string</code> 就是两个不同的类型了，这里的 <code>MyString</code> 是不同于任何类型的新类型。</p>
<p>这种方式也叫做类型的在定义，即：把 <code>string</code> 类型在定义为 <code>MyString</code> 类型。</p>
<p><p class="md__image">
  <img src=".././image/4f113b74b564ad3b4b4877abca7b6bf2.png"
    alt=""  />
</p>
</p>
<p>对应类型再定义来说，<code>string</code> 可以被称为 <code>MyString</code> 的潜在类型，潜在类型的含义就是某个类型的本质上是什么类型。</p>
<p>潜在类型相同的不同类型的值之间是可以进行类型转换的。所以 <code>MyString</code> 类型的值与 <code>string</code> 类型的值可以使用类型转换表达式互转。</p>
<p>但由于类型再定义后属于不同的类型，不同类型直接不可以做判等或者比较，也不能直接赋值。</p>
]]></content>
		</item>
		
		<item>
			<title>Go 语言中的作用域那些事儿</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_scope/</link>
			<pubDate>Wed, 09 Dec 2020 15:43:38 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_scope/</guid>
			<description>作用域是什么 一个程序实体被写出来，就是为了让其他程序引用。哪里的代码可以引用它呢，这就涉及到了它的作用域。 Go 语言的访问权限有三种：包级私有的</description>
			<content type="html"><![CDATA[<h2 id="作用域是什么">作用域是什么</h2>
<p>一个程序实体被写出来，就是为了让其他程序引用。哪里的代码可以引用它呢，这就涉及到了它的作用域。</p>
<p><code>Go</code> 语言的访问权限有三种：包级私有的、模块级私有的和公开的。这其实就是 <code>Go</code> 语言在语言层面依据代码块对程序实体作用域进行的定义。</p>
<p>我在函数里面声明了一个变量，一般情况下这个变量无法被函数外部使用。变量的作用域就被限定在函数体里面。</p>
<p>所以，一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制。</p>
<h3 id="一个变量与其外层代码块中的变量重名会怎样">一个变量与其外层代码块中的变量重名会怎样</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">var</span> <span class="nx">block</span> <span class="p">=</span> <span class="s">&#34;package&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">block</span> <span class="o">:=</span> <span class="s">&#34;function&#34;</span>
	<span class="p">{</span>
		<span class="nx">block</span> <span class="o">:=</span> <span class="s">&#34;inner&#34;</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;this block is %s!\n&#34;</span><span class="p">,</span> <span class="nx">block</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;this block is %s!\n&#34;</span><span class="p">,</span> <span class="nx">block</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这段代码里面有四个代码块：全局代码块、<code>main</code> 包代码块、<code>main</code> 函数代码块和函数内部一对花括号代码块。</p>
<p>执行 <code>go run main.go</code> ：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">this</span> <span class="nx">block</span> <span class="nx">is</span> <span class="nx">inner</span><span class="p">!</span>
<span class="nx">this</span> <span class="nx">block</span> <span class="nx">is</span> <span class="nx">function</span><span class="p">!</span>
</code></pre></div><p>我们发现当前代码块里面的变量会把外层代码块的变量覆盖掉。这是因为 <code>Go</code> 语言中的变量查找过程：</p>
<ul>
<li>首先，代码引用变量时优先查找当前代码块中的变量。</li>
<li>其次，如果当前代码块中没有声明该变量，那么会沿着嵌套关系一层一层往上找。</li>
<li>一般会查到当前代码块所在的代码包，如果仍然查不到，就会报编译错误。</li>
</ul>
<blockquote>
<p>有个特殊情况，如果使用 <code>import . &quot;XXX&quot;</code> 的形式引入代码包，那么该包会被视为当前代码包中的程序实体。</p>
</blockquote>
<h3 id="不同代码块的重名变量可重名变量和变量重声明中的变量区别">不同代码块的重名变量（可重名变量）和变量重声明中的变量区别</h3>
<ul>
<li>变量重声明的变量是在同一个代码块内的，而可重名变量是在不同代码块之间由相同标识符代表的变量。</li>
<li>变量重声明是对同一个变量多次声明，是针对一个变量，而可重名变量是多个变量。</li>
<li>变量重声明不论声明多少次，变量的类型是首次声明就确定了的，而可重名变量的类型不受限制。</li>
<li>可重命名变量所在的代码块之间是存在直接或间接的嵌套关系的，他们之间一定会存在”屏蔽“的现象。</li>
</ul>
<p><p class="md__image">
  <img src=".././image/5e68210d5639f9e42738f21bd9eb1e89.png"
    alt=""  />
</p>
</p>
]]></content>
		</item>
		
		<item>
			<title>Go 语言中的变量那些事儿</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_var/</link>
			<pubDate>Wed, 09 Dec 2020 09:23:22 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_var/</guid>
			<description>变量声明 除了 var name string 这种声明方式以外还有两种基于类型推断的声明方式。 注意短变量声明只能在函数体内部使用。 类型推断 类型推断是编程语言在编译器自动</description>
			<content type="html"><![CDATA[<h2 id="变量声明">变量声明</h2>
<p><p class="md__image">
  <img src=".././image/b7d73fdce13a3a5f2d56d0b95f2c8cbc.png"
    alt=""  />
</p>
</p>
<p>除了 <code>var name string</code> 这种声明方式以外还有两种基于类型推断的声明方式。</p>
<p>注意短变量声明只能在函数体内部使用。</p>
<h2 id="类型推断">类型推断</h2>
<p>类型推断是编程语言在编译器自动解释表达式类型的能力。即：对表达式进行求值后的结果的类型推断。</p>
<h3 id="类型推断的好处">类型推断的好处</h3>
<p>类型推断可以明显提升程序的灵活性，使得代码重构变的更容易，同时又不会给代码的维护增加额外的负担（实际上，它恰恰可以避免散弹式的代码修改）更不会损失程序的运行效率。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">name</span> <span class="p">=</span> <span class="nf">getFlag</span><span class="p">()</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Hello %v!\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getFlag</span><span class="p">()</span> <span class="o">*</span><span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;Joseph&#34;</span><span class="p">,</span> <span class="s">&#34;This greeting object.&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们给变量 <code>name</code> 赋值时使用了函数封装，对 <code>flag.String</code> 函数的调用，并把其结果直接作为 <code>getFlag</code> 函数的结果，结果的类型是<code>*string</code>。这样变量赋值就变为针对 <code>getFlag</code> 函数的返回值了。这实际上是对声明并赋值 <code>name</code> 变量的那行代码的重构。</p>
<blockquote>
<p>我们通常把不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现”的代码修改方式，叫做对该程序的重构。重构的对象可以是一行代码、一个函数、一个功能模块，甚至一个软件系统。</p>
</blockquote>
<p>接下来，我想要改变 <code>getFlag</code> 里面的代码对 <code>main</code> 函数不会有任何影响。</p>
<h3 id="变量的重声明">变量的重声明</h3>
<p>通过使用短变量声明，我们可以在同一个代码块中对变量进行重声明。即：对已经存在的变量再次声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
<span class="nx">name</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="s">&#34;Hello, everyone!\n&#34;</span><span class="p">)</span>
</code></pre></div><p>使用短变量声明对新变量 <code>name</code> 和旧变量 <code>err</code> 进行了“声明并赋值”，这时也是对后者的重声明。</p>
<p>使用变量的重声明有几个前提条件：</p>
<ul>
<li>变量的类型初始化时已经确定了，所以重声明时变量类型必须和之前保持一致。</li>
<li>变量的初始和重声明必须发生在同一个代码块中。</li>
<li>变量的重声明只有在使用短变量声明是才会发生。</li>
<li>重声明时的变量必须是多个且至少有一个是新变量。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>库源码文件和代码拆分</title>
			<link>https://zhangxuesong.github.io/posts/gocore/lib_source/</link>
			<pubDate>Tue, 08 Dec 2020 13:12:08 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/lib_source/</guid>
			<description>什么是库源码文件 库源码文件是不能直接运行的源码文件，它仅提供程序实体以供其他代码使用。如： package lib5 import &amp;#34;fmt&amp;#34; func Hello(name string) { fmt.Printf(&amp;#34;Hello %s!\n&amp;#34;, name) } 把上面代码保存到 libSource.go 执行 go run</description>
			<content type="html"><![CDATA[<h2 id="什么是库源码文件">什么是库源码文件</h2>
<p>库源码文件是不能直接运行的源码文件，它仅提供程序实体以供其他代码使用。如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">lib5</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">Hello</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Hello %s!\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>把上面代码保存到 <code>libSource.go</code> 执行 <code>go run libSource.go</code> 得到：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">run</span><span class="p">:</span> <span class="nx">cannot</span> <span class="nx">run</span> <span class="nx">non</span><span class="o">-</span><span class="nx">main</span> <span class="kn">package</span>
</code></pre></div><h2 id="怎样把命令源码文件中的代码拆分到其他库源码文件">怎样把命令源码文件中的代码拆分到其他库源码文件？</h2>
<p>首先来看代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;flag&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;Joseph&#34;</span><span class="p">,</span> <span class="s">&#34;The greeting object.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="nf">hello</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这里 <code>main</code> 没有直接输出，而是调用了 <code>hello()</code> 函数，函数声明在另一个源码文件中，我们把他命名为 <code>libSource.go</code> 并且把他放在和 <code>main.go</code> 相同的目录下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">hello</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span>  <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Hello %s!\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>执行命令 <code>go run main.go libSource.go</code>，得到结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Hello</span> <span class="nx">Joseph</span><span class="p">!</span>
</code></pre></div><p>注意，<code>main.go</code> 和 <code>libSource.go</code> 都声明自己属于 <code>main</code> 包，这是因为同一个目录下的源码文件必须要被声明为同一代码包，否则会报错：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">found</span> <span class="nx">packages</span> <span class="nf">main</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">)</span> <span class="nx">and</span> <span class="nf">main1</span> <span class="p">(</span><span class="nx">libSource</span><span class="p">.</span><span class="k">go</span><span class="p">)</span> <span class="nx">in</span> <span class="cm">/***/</span><span class="nx">gowork</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">gocore</span><span class="o">/</span><span class="nx">libSource</span>
</code></pre></div><p>这句话是说在目录下找到了两个包。</p>
<p>另外也要注意源码文件声明的包名和所在的目录可以不相同，只要这些文件声明的包名一致就可以。</p>
<h2 id="怎么把命令源码文件拆分到其他代码包">怎么把命令源码文件拆分到其他代码包</h2>
<p>在 <code>main.go</code> 目录下新建目录 <code>lib</code> 并且创建文件 <code>libSource.go</code> 代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">lib5</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">Hello</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Hello %s!\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>目前结构如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="p">.</span>
<span class="err">├──</span> <span class="k">go</span><span class="p">.</span><span class="nx">mod</span>
<span class="err">├──</span> <span class="nx">lib</span>
<span class="err">│</span>   <span class="err">└──</span> <span class="nx">libSource</span><span class="p">.</span><span class="k">go</span>
<span class="err">├──</span> <span class="nx">libSource</span><span class="p">.</span><span class="k">go</span>
<span class="err">└──</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
</code></pre></div><p>这里和外面的 <code>libSource.go</code> 对比改了两个地方，一个是包名改了，并且和目录名不同，一个是 <code>Hello</code> 函数首字母改成了大写。</p>
<h2 id="代码包的导入路径和其所在的目录的相对路径是否一致">代码包的导入路径和其所在的目录的相对路径是否一致</h2>
<p>库文件源码 <code>libSource.go</code> 所在目录的相对目录是 <code>lib</code> 但它却声明自己属于 <code>lib5</code> 包，那么该包的导入路径是 <code>libsource/lib</code> 呢还是 <code>libsource/lib5</code> 呢？<code>libsource</code> 是我的 <code>main.go</code> 所在目录。</p>
<p>我们来安装下库源码文件，执行命令 <code>go install lib/libSource.go</code> 然后看 <code>main.go</code> 做了哪些改动：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;libsource/lib&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;Joseph&#34;</span><span class="p">,</span> <span class="s">&#34;The greeting object.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="c1">//hello(name)
</span><span class="c1"></span>	<span class="nx">lib5</span><span class="p">.</span><span class="nf">Hello</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>首先在以 <code>import</code> 为前导的代码包导入语句中加入 <code>libsource/lib</code> 试图导入代码包。</p>
<p>然后把对 <code>hello</code> 函数的调用改为对 <code>lib.Hello</code> 函数的调用。其中的 <code>lib.</code> 叫做限定符，旨在指明右边的程序实体所在的代码包。不过这里与代码包导入路径的完整写法不同，只包含了路径中的最后一级 <code>lib</code>，这与代码包声明语句中的规则一致。</p>
<p>执行 <code>go run main.go</code> 错误提示如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="p">.</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span> <span class="nx">imported</span> <span class="nx">and</span> <span class="nx">not</span> <span class="nx">used</span><span class="p">:</span> <span class="s">&#34;libsource/lib&#34;</span> <span class="nx">as</span> <span class="nx">lib5</span>
<span class="p">.</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">17</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span> <span class="nx">undefined</span><span class="p">:</span> <span class="nx">lib</span>
</code></pre></div><p>第一行是说我们导入了 <code>libsource/lib</code> 但没有使用，<code>Go</code> 语言是不允许的，会报编译错误。</p>
<p>第二行是说没找到 <code>lib</code> 包。另外注意第一行的 <code>as lib5</code> 这是说我们虽然导入的是 <code>libsource/lib</code> 但是使用的应该是 <code>lib5</code>。</p>
<p>这里要记住源码文件所在的目录是相对于 <code>src</code> 目录的相对路径就是他的导入路径，而实际使用的是源码文件声明的所属包名。</p>
<p>为了不产生困惑，我们应该尽量保持包名与父目录名称一致。</p>
<h2 id="什么样的程序才能够被外部代码引用">什么样的程序才能够被外部代码引用</h2>
<p>名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。</p>
<p>通过名称，<code>Go</code> 语言自然地把程序实体的访问权限划分为了包级私有的和公开的。对于包级私有的程序实体，即使你导入了它所在的代码包也无法引用到它。</p>
<p>这也是我们上面代码中把 <code>hello</code> 改为 <code>lib5.Hello</code> 的原因。</p>
<h2 id="其他的访问权限规则">其他的访问权限规则</h2>
<p>在 <code>Go 1.5</code> 及后续版本中，我们可以通过创建 <code>internal</code> 代码包让一些程序实体仅仅能被当前模块中的其他代码引用。这被称为 <code>Go</code> 程序实体的第三种访问权限：模块级私有。</p>
<p>具体规则是，<code>internal</code> 代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用。当然，引用前需要先导入这个  <code>internal</code> 包。对于其他代码包，导入该 <code>internal</code> 包都是非法的，无法通过编译。</p>
<p>当前结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="p">.</span>
<span class="err">├──</span> <span class="k">go</span><span class="p">.</span><span class="nx">mod</span>
<span class="err">├──</span> <span class="nx">lib</span>
<span class="err">│</span>   <span class="err">├──</span> <span class="nx">internal</span>
<span class="err">│</span>   <span class="err">│</span>   <span class="err">└──</span> <span class="nx">internal</span><span class="p">.</span><span class="k">go</span>
<span class="err">│</span>   <span class="err">└──</span> <span class="nx">libSource</span><span class="p">.</span><span class="k">go</span>
<span class="err">├──</span> <span class="nx">libSource</span><span class="p">.</span><span class="k">go</span>
<span class="err">└──</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
</code></pre></div><p>我们把 <code>lib/libSource.go</code> 中的 <code>Hello</code> 函数拆分到 <code>lib/internal/internal.go</code> 实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">internal</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">Hello</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span>  <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Hello %s!\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><code>lib/libSource.go</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">lib5</span>

<span class="kn">import</span> <span class="s">&#34;libsource/lib/internal&#34;</span>

<span class="kd">func</span> <span class="nf">Hello</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//fmt.Printf(&#34;Hello %s!\n&#34;, name)
</span><span class="c1"></span>	<span class="nx">internal</span><span class="p">.</span><span class="nf">Hello</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><code>main.go</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;libsource/lib&#34;</span>
	<span class="s">&#34;libsource/lib/internal&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;Joseph&#34;</span><span class="p">,</span> <span class="s">&#34;The greeting object.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="c1">//hello(name)
</span><span class="c1"></span>	<span class="nx">lib5</span><span class="p">.</span><span class="nf">Hello</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们在 <code>main.go</code> 引入了  <code>internal</code> 包，执行 <code>go run main.go</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">command</span><span class="o">-</span><span class="nx">line</span><span class="o">-</span><span class="nx">arguments</span>
        <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span> <span class="nx">use</span> <span class="nx">of</span> <span class="nx">internal</span> <span class="kn">package</span> <span class="nx">libsource</span><span class="o">/</span><span class="nx">lib</span><span class="o">/</span><span class="nx">internal</span> <span class="nx">not</span> <span class="nx">allowed</span>
</code></pre></div><p>可见是不被允许的，把 <code>libsource/lib/internal</code> 注释掉在执行：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Hello</span> <span class="nx">Joseph</span><span class="p">!</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>命令源码文件和 flag 库</title>
			<link>https://zhangxuesong.github.io/posts/gocore/command_source/</link>
			<pubDate>Mon, 07 Dec 2020 14:05:35 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/command_source/</guid>
			<description>前言 写了N年代码，只知道源码文件，原来细分的话源码文件也有区分，如： 命令源码文件 库源码文件 测试源码文件 他们也有不同的用途和规则。 命令源码文件</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>写了N年代码，只知道源码文件，原来细分的话源码文件也有区分，如：</p>
<ul>
<li>命令源码文件</li>
<li>库源码文件</li>
<li>测试源码文件</li>
</ul>
<p>他们也有不同的用途和规则。</p>
<h2 id="命令源码文件">命令源码文件</h2>
<p>命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。通过执行构建和安装，生成其对应的可执行文件，可执行文件一般与命令源码文件的父级目录同名。</p>
<p>如果一个源码文件声明属于<code>main</code>包，并且包含一个无参数声明并且无结果声明的<code>main</code>函数，那面它就是命令源码文件，如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span>  <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello go!!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>把这段代码保存到 <code>main.go</code> 文件，执行 <code>go run main.go</code> 就会输出 <code>hello go!!</code></p>
<blockquote>
<p>通常模块化编程时，我们会把代码拆分到多个文件，甚至拆分到不同的代码包中。但不管怎样，对于一个独立的程序来说，命令源码文件永远也只会有一个。如果有与命令源码文件同包的源码文件，那么它们也应该声明属于main包。</p>
</blockquote>
<p>通过构建或安装命令源码文件可以生成可执行文件，这里的可执行文件就可以视为“命令”，既然是命令，那面就应该具备接受参数的能力。</p>
<h3 id="命令源码文件怎样接收参数">命令源码文件怎样接收参数</h3>
<p>接收参数我们需要用到 <code>flag</code> 包 ，它是 <code>Go</code> 语言标准库提供的专门解析命令行参数的代码包。具体怎么使用呢，我们来看代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;Joseph&#34;</span><span class="p">,</span> <span class="s">&#34;The greeting object.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span>  <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;hello %s!\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>上面代码中，我们用 <code>flag.StringVar()</code> 函数，该函数接收 4 个参数：</p>
<ul>
<li>第一个参数是用于存储命令参数值的地址，我们这里就是前面声明的 <code>name</code> 变量的地址了，这里用 <code>&amp;name</code> 表示。</li>
<li>第二个参数是指定该命令接收的参数名称，这里是 <code>name</code> 。</li>
<li>第三个参数是指定了未输入该命令参数时的默认值，这里是 <code>Joseph</code>。</li>
<li>第四个参数是该命令参数的简短说明，<code>--help</code> 时会用到。</li>
</ul>
<p>另外这里还有个相似的函数 <code>flag.String()</code> 区别是前者把接收到的命令参数值绑定到了指定的变量，后者直接返回了命令参数值的指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;Joseph&#34;</span><span class="p">,</span> <span class="s">&#34;The greeting object.&#34;</span><span class="p">)</span>
</code></pre></div><p>参数列表少了第一个。</p>
<p>函数  <code>flag.Parse()</code> 用于真正解析命令参数，并把它们赋值给相应变量。对该函数的调用必须在所有命令参数存储载体声明（变量 <code>name</code> 声明）和设置（对 <code>flag.StringVal()</code> 调用）之后，并且在读取任何命令参数值之前进行。所以，我们最好把它放在 <code>main</code> 函数体的第一行。</p>
<h3 id="怎样在运行命令源码文件的时候传入参数怎样查看参数说明">怎样在运行命令源码文件的时候传入参数，怎样查看参数说明</h3>
<p>把上面代码保存到 <code>main.go</code> 文件，运行下面命令就可以为参数 <code>name</code> 传值：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">run</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span> <span class="o">-</span><span class="nx">name</span><span class="p">=</span><span class="s">&#34;golang&#34;</span>
</code></pre></div><p>运行后，输出结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">hello</span> <span class="nx">golang</span><span class="p">!</span>
</code></pre></div><p>查看参数说明可以执行下面命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">run</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span> <span class="o">--</span><span class="nx">help</span>
</code></pre></div><p>运行后结果类似：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Usage</span> <span class="nx">of</span> <span class="o">/</span><span class="kd">var</span><span class="o">/</span><span class="nx">folders</span><span class="o">/</span><span class="nx">nt</span><span class="o">/</span><span class="nx">vczl6v_963vb3pr63m_v12kh0000gn</span><span class="o">/</span><span class="nx">T</span><span class="o">/</span><span class="k">go</span><span class="o">-</span><span class="nx">build422118775</span><span class="o">/</span><span class="nx">b001</span><span class="o">/</span><span class="nx">exe</span><span class="o">/</span><span class="nx">main</span><span class="p">:</span>
  <span class="o">-</span><span class="nx">name</span> <span class="kt">string</span>
        <span class="nx">The</span> <span class="nx">greeting</span> <span class="nx">object</span><span class="p">.</span> <span class="p">(</span><span class="k">default</span> <span class="s">&#34;Joseph&#34;</span><span class="p">)</span>
</code></pre></div><p>其中：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">/</span><span class="kd">var</span><span class="o">/</span><span class="nx">folders</span><span class="o">/</span><span class="nx">nt</span><span class="o">/</span><span class="nx">vczl6v_963vb3pr63m_v12kh0000gn</span><span class="o">/</span><span class="nx">T</span><span class="o">/</span><span class="k">go</span><span class="o">-</span><span class="nx">build422118775</span><span class="o">/</span><span class="nx">b001</span><span class="o">/</span><span class="nx">exe</span><span class="o">/</span><span class="nx">main</span>
</code></pre></div><p>是 <code>go run</code> 命令构建源码文件所产生的临时可执行文件存储路径。</p>
<p>如果先构建源码文件在执行，像这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">build</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
<span class="p">.</span><span class="o">/</span><span class="nx">main</span> <span class="o">--</span><span class="nx">help</span>
</code></pre></div><p>那面输出就是：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Usage</span> <span class="nx">of</span> <span class="p">.</span><span class="o">/</span><span class="nx">main</span><span class="p">:</span>
  <span class="o">-</span><span class="nx">name</span> <span class="kt">string</span>
        <span class="nx">The</span> <span class="nx">greeting</span> <span class="nx">object</span><span class="p">.</span> <span class="p">(</span><span class="k">default</span> <span class="s">&#34;Joseph&#34;</span><span class="p">)</span>
</code></pre></div><h3 id="怎样自定义命令源码文件的参数使用说明">怎样自定义命令源码文件的参数使用说明</h3>
<h4 id="1对变量-flagusage-重新赋值">1、对变量 <code>flag.Usage</code> 重新赋值</h4>
<p><code>flag.Usage</code> 的类型是 <code>func()</code>，是一种无参数声明且无返回结果声明的函数类型。其在声明的时候就已经被赋值了，所以运行命令 <code>--help</code> 时才能看到结果。</p>
<p>我们对 <code>flag.Usage</code> 进行赋值必须在 <code>flag.Parse</code> 之前，如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span>  <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nx">Usage</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;%s使用说明:\n&#34;</span><span class="p">,</span> <span class="s">&#34;参数&#34;</span><span class="p">)</span>
		<span class="nx">flag</span><span class="p">.</span><span class="nf">PrintDefaults</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;hello %s!\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>执行 <code>--help</code> 命令得到：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">参数使用说明</span><span class="p">:</span>
  <span class="o">-</span><span class="nx">name</span> <span class="kt">string</span>
        <span class="nx">The</span> <span class="nx">greeting</span> <span class="nx">object</span><span class="p">.</span> <span class="p">(</span><span class="k">default</span> <span class="s">&#34;Joseph&#34;</span><span class="p">)</span>
</code></pre></div><h4 id="2对变量-flagcommandline-重新赋值">2、对变量 <code>flag.CommandLine</code> 重新赋值</h4>
<p>我们在调用 <code>flag</code> 包中的一些函数如：<code>StringVal</code>、<code>Parse</code> 时实际在调用 <code>flag.CommandLine</code> 变量的对应方法。</p>
<p><code>flag.CommandLine</code> 相当于默认的命令参数容器，通过对其重新赋值，可以更深层次的定制当前命令源码文件的参数说明。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="c1">//var name = flag.String(&#34;name&#34;, &#34;Joseph&#34;, &#34;The greeting object.&#34;)
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nx">CommandLine</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">NewFlagSet</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">ExitOnError</span><span class="p">)</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nx">CommandLine</span><span class="p">.</span><span class="nx">Usage</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;%s使用说明:\n&#34;</span><span class="p">,</span> <span class="s">&#34;参数&#34;</span><span class="p">)</span>
		<span class="nx">flag</span><span class="p">.</span><span class="nf">PrintDefaults</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">flag</span><span class="p">.</span><span class="nf">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;Joseph&#34;</span><span class="p">,</span> <span class="s">&#34;The greeting object.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span>  <span class="p">{</span>
	<span class="c1">//flag.Usage = func() {
</span><span class="c1"></span>	<span class="c1">//	fmt.Fprintf(os.Stderr, &#34;%s使用说明:\n&#34;, &#34;参数&#34;)
</span><span class="c1"></span>	<span class="c1">//	flag.PrintDefaults()
</span><span class="c1"></span>	<span class="c1">//}
</span><span class="c1"></span>	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;hello %s!\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><code>flag.NewFlagSet()</code> 的第二个参数可以设置使用 <code>--help</code> 时的响应状态，比如：</p>
<ul>
<li>设为 <code>flag.ContinueOnError</code> 时得到结果：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">参数使用说明</span><span class="p">:</span>
  <span class="o">-</span><span class="nx">name</span> <span class="kt">string</span>
        <span class="nx">The</span> <span class="nx">greeting</span> <span class="nx">object</span><span class="p">.</span> <span class="p">(</span><span class="k">default</span> <span class="s">&#34;Joseph&#34;</span><span class="p">)</span>
<span class="nx">hello</span> <span class="nx">Joseph</span><span class="p">!</span>
</code></pre></div><ul>
<li>设为 <code>flag.ExitOnError</code> 时得到结果：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">参数使用说明</span><span class="p">:</span>
  <span class="o">-</span><span class="nx">name</span> <span class="kt">string</span>
        <span class="nx">The</span> <span class="nx">greeting</span> <span class="nx">object</span><span class="p">.</span> <span class="p">(</span><span class="k">default</span> <span class="s">&#34;Joseph&#34;</span><span class="p">)</span>
</code></pre></div><ul>
<li>设为 <code>flag.PanicOnError</code> 时得到结果：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">参数使用说明</span><span class="p">:</span>
  <span class="o">-</span><span class="nx">name</span> <span class="kt">string</span>
        <span class="nx">The</span> <span class="nx">greeting</span> <span class="nx">object</span><span class="p">.</span> <span class="p">(</span><span class="k">default</span> <span class="s">&#34;Joseph&#34;</span><span class="p">)</span>
<span class="nx">panic</span><span class="p">:</span> <span class="nx">flag</span><span class="p">:</span> <span class="nx">help</span> <span class="nx">requested</span>

<span class="nx">goroutine</span> <span class="mi">1</span> <span class="p">[</span><span class="nx">running</span><span class="p">]:</span>
<span class="nx">flag</span><span class="p">.(</span><span class="o">*</span><span class="nx">FlagSet</span><span class="p">).</span><span class="nf">Parse</span><span class="p">(</span><span class="mh">0xc0000561e0</span><span class="p">,</span> <span class="mh">0xc00000c090</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="mh">0xc000068f78</span><span class="p">,</span> <span class="mh">0x1005a65</span><span class="p">)</span>
        <span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.15.5</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">flag</span><span class="o">/</span><span class="nx">flag</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">987</span> <span class="o">+</span><span class="mh">0x145</span>
<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="o">/</span><span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">Cellar</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="mf">1.15.5</span><span class="o">/</span><span class="nx">libexec</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">flag</span><span class="o">/</span><span class="nx">flag</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">1002</span>
<span class="nx">main</span><span class="p">.</span><span class="nf">main</span><span class="p">()</span>
        <span class="o">/</span><span class="nx">Users</span><span class="o">/</span><span class="nx">zhangxuesong</span><span class="o">/</span><span class="nx">gowork</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">gocore</span><span class="o">/</span><span class="nx">commandSource</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">27</span> <span class="o">+</span><span class="mh">0x85</span>
<span class="nx">exit</span> <span class="nx">status</span> <span class="mi">2</span>
</code></pre></div><h4 id="3创建私有命令参数容器">3、创建私有命令参数容器</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="c1">//var name = flag.String(&#34;name&#34;, &#34;Joseph&#34;, &#34;The greeting object.&#34;)
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">name</span> <span class="kt">string</span>
<span class="kd">var</span> <span class="nx">cmdLine</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">NewFlagSet</span><span class="p">(</span><span class="s">&#34;参数&#34;</span><span class="p">,</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">ExitOnError</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//flag.CommandLine = flag.NewFlagSet(&#34;&#34;, flag.ExitOnError)
</span><span class="c1"></span>	<span class="c1">//flag.CommandLine.Usage = func() {
</span><span class="c1"></span>	<span class="c1">//	fmt.Fprintf(os.Stderr, &#34;%s使用说明:\n&#34;, &#34;参数&#34;)
</span><span class="c1"></span>	<span class="c1">//	flag.PrintDefaults()
</span><span class="c1"></span>	<span class="c1">//}
</span><span class="c1"></span>
	<span class="c1">//flag.StringVar(&amp;name, &#34;name&#34;, &#34;Joseph&#34;, &#34;The greeting object.&#34;)
</span><span class="c1"></span>
	<span class="nx">cmdLine</span><span class="p">.</span><span class="nf">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;Joseph&#34;</span><span class="p">,</span> <span class="s">&#34;The greeting object.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span>  <span class="p">{</span>
	<span class="c1">//flag.Usage = func() {
</span><span class="c1"></span>	<span class="c1">//	fmt.Fprintf(os.Stderr, &#34;%s使用说明:\n&#34;, &#34;参数&#34;)
</span><span class="c1"></span>	<span class="c1">//	flag.PrintDefaults()
</span><span class="c1"></span>	<span class="c1">//}
</span><span class="c1"></span>	<span class="c1">//flag.Parse()
</span><span class="c1"></span>
	<span class="nx">cmdLine</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;hello %s!\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><p>需要注意的是 <code>os.Args[1:]</code> 表示解析参数从第二个开始，第一个是文件名。</p>
]]></content>
		</item>
		
		<item>
			<title>go build和go get</title>
			<link>https://zhangxuesong.github.io/posts/gocore/go_build_get/</link>
			<pubDate>Sun, 06 Dec 2020 16:42:20 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/go_build_get/</guid>
			<description>go build go build运行的时候默认不会编译目标代码包所依赖的那些代码包。当被依赖的代码包的归档文件不存在或者源码文件有变化才会被编译。 使用命令g</description>
			<content type="html"><![CDATA[<h2 id="go-build"><code>go build</code></h2>
<p><code>go build</code>运行的时候默认不会编译目标代码包所依赖的那些代码包。当被依赖的代码包的归档文件不存在或者源码文件有变化才会被编译。</p>
<p>使用命令<code>go build -a</code>可以强制编译依赖包，即使依赖的是标准库中的代码包。</p>
<p>使用命令<code>go build -i</code>不但能强制编译依赖包，还会安装他们的归档文件。</p>
<p>使用命令<code>go build -x</code>可以看到具体执行了哪些操作，也可以使用<code>go build -n</code>只查看而不操作。</p>
<p>使用命令<code>go build -v</code>可以看到编译的代码包的名称。</p>
<h2 id="go-get"><code>go get</code></h2>
<p><code>go get</code>会自动从一些主流共用代码仓库下载代码包，并且安装到<code>GOPATH</code>指向的第一个工作区中的对应目录。如果设置了<code>GOBIN</code>,那面仅包含命令源码文件的代码包会被安装到<code>GOBIN</code>指向的目录。</p>
<p>常用参数：</p>
<ul>
<li><code>-u</code>下载并安装代码包，不论工作区中是否已存在。</li>
<li><code>-d</code>只下载不安装代码包。</li>
<li><code>-fix</code>下载代码包后先运行一个当前<code>Go</code>版本的修正代码工具，然后安装。</li>
<li><code>-t</code>同时下载测试所需代码包。</li>
<li><code>-insecure</code>允许通过非安全的网络协议下载和安装代码包，比如<code>HTTP</code>协议。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Gopath和工作区</title>
			<link>https://zhangxuesong.github.io/posts/gocore/gopath/</link>
			<pubDate>Sat, 05 Dec 2020 11:10:05 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/gopath/</guid>
			<description>前言 我们都知道 Go 的环境安装需要配置三个环境变量，他们分别是： GPROOT：Go语言安装根目录的路径，也就是Go语言的安装路径。 GOBIN：G</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>我们都知道 <code>Go</code> 的环境安装需要配置三个环境变量，他们分别是：</p>
<ul>
<li>GPROOT：<code>Go</code>语言安装根目录的路径，也就是<code>Go</code>语言的安装路径。</li>
<li>GOBIN：<code>Go</code>程序生成的可执行文件（executable file）的路径。</li>
<li>GOPATH：指向工作区目录的路径，是我们自定义的工作空间，可定义多个。</li>
</ul>
<h2 id="设置-gopath-有什么意义">设置 <code>GOPATH</code> 有什么意义？</h2>
<p>之前只知道<code>GOPATH</code>是<code>Go</code>语言的工作目录，他的值是一个或者多个路径（不同系统分隔符不同），每个路径代表<code>Go</code>语言的一个工作区。</p>
<p>我们利用这些工作区去防止<code>Go</code>语言的源码文件（source file），已经安装后的归档文件（archive file）和可执行文件（executable file）。</p>
<p>事实上，由于<code>Go</code>语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本上都是围绕<code>GOPATH</code>和工作区进行的。所以它的背后还有以下几个知识点，分别是：</p>
<h3 id="1go语言源码的组织方式">1、<code>Go</code>语言源码的组织方式</h3>
<p><code>Go</code>语言的源码是以代码包为基本单位的。在文件系统中，这些代码包和目录是一一对应的。由于目录可以有子目录，所以代码包也可以有子包。</p>
<p>一个代码包中可以包含任意个以<code>.go</code>为扩展名的源码文件，这些源码文件都需要被声明属于同一个代码包。</p>
<p>代码包的名称一般会与源码文件所在的目录同名。如果不同名，那么在构建、安装的过程中会以代码包名称为准。</p>
<p>每个代码包都有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。在实际使用程序实体前，我们必须先导入其所在的代码包。具体方式就是<code>import</code>该包的导入路径。就像这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;github.com/labstack/echo&#34;</span>
</code></pre></div><p>在工作区中，一个代码包的导入路径就是从<code>src</code>的子目录，到该包的实际存储位置的相对路径。</p>
<p>所以说，<code>Go</code>语言源码的组织方式就是以环境变量<code>GOPATH</code>、工作区、<code>src</code>目录和代码包为主线的。一般情况下，<code>Go</code>语言的源码文件都需要被存放在环境变量<code>GOPATH</code>包含的某个工作区（目录）中的<code>src</code>目录下的某个代码包（目录）中。</p>
<h3 id="2源码安装后的结果">2、源码安装后的结果</h3>
<p>源码文件通常放在工作区下的<code>src</code>子目录下；安装后如果产生了归档文件，就会放到该工作区的<code>pkg</code>子目录；如果产生了可以执行文件，就会放进该工作区的<code>bin</code>子目录下。</p>
<p>源码文件是以代码包的形式组织起来的，一个代码包其实就对应一个目录。安装某个代码包而产生的归档文件是与这个代码包同名的。</p>
<p>放置他的相对目录就是该包的导入路径的直接父级。</p>
<p>比如，一个已存在的代码包的导入路径是：<code>github.com/labstack/echo</code>那么执行命令</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nx">install</span> <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">labstack</span><span class="o">/</span><span class="nx">echo</span>
</code></pre></div><p>生成的归档文件就是：<code>github.com/labstack</code>，文件名为<code>echo.a</code>。</p>
<p>上面这个代码包还有一层含义就是：该代码包的源码文件存放于<code>Github</code>上的<code>labstack</code>组的代码仓库<code>echo</code>中。</p>
<p>归档文件的相对目录与<code>pkg</code>目录直接还有一层平台相关目录。平台相关目录的名称是由<code>build</code>（也称“构建”）的目标操作系统、下划线和目标计算架构的代号组成的。如：<code>linux_amd64</code>。</p>
<p><p class="md__image">
  <img src="../image/2fdfb5620e072d864907870e61ae5f3c.png"
    alt=""  />
</p>
</p>
<p>所以，我们知道某个工作区的 src 子目录下的源码文件在安装后一般会被放置到当前工作区的 pkg 子目录下对应的目录中，或者被直接放置到该工作区的 bin 子目录中。</p>
<h3 id="3构建和安装-go-程序的过程">3、构建和安装 Go 程序的过程</h3>
<p>构建使用命令<code>go build</code>，安装使用命令<code>go install</code>。构建和安装代码时都会执行编译、打包等操作，并且这些操作生成的任何文件都会先保存在某个临时目录中。</p>
<p>如果构建的是库源码文件，操作产生的结果文件只会存放在临时目录中。这里的构建的主要意义在于检查和验证。</p>
<p>如果构建的是命令源码文件，操作产生过的结果文件会被搬运到源码文件所在的目录中。</p>
<p>安装操作会先执行构建，然后执行链接操作，并且把结果文件搬运到指定目录。</p>
<p>进一步说，如果安装的是库源码文件，那么结果文件会被搬运到所在工作区的<code>pkg</code>目录下的某个子目录中。</p>
<p>如果安装的是命令源码文件，那么结果过文件会被搬运到所在工作区的<code>bin</code>目录中或者环境变量<code>GOBIN</code>指向的目录中。</p>
<h2 id="补充">补充</h2>
<h3 id="1go语言在多个工作区中查找依赖包是以怎样的顺序进行的">1、<code>Go</code>语言在多个工作区中查找依赖包是以怎样的顺序进行的？</h3>
<p>以<code>GOPATH</code>指定的工作区顺序查找，找到即返回，找不到则报错。</p>
<h3 id="2多个工作区中都存在导入路径相同的代码包会产生冲突吗">2、多个工作区中都存在导入路径相同的代码包会产生冲突吗？</h3>
<p>不会冲突，原因同上。同理，不同工作区的两个相同导入路径的代码包，编译的时候不会编译第二个工作区的代码包。</p>
]]></content>
		</item>
		
		<item>
			<title>My First Post</title>
			<link>https://zhangxuesong.github.io/posts/gocore/my-first-post/</link>
			<pubDate>Fri, 04 Dec 2020 10:11:10 +0800</pubDate>
			
			<guid>https://zhangxuesong.github.io/posts/gocore/my-first-post/</guid>
			<description>这是第一篇文章</description>
			<content type="html"><![CDATA[<p>这是第一篇文章</p>
]]></content>
		</item>
		
	</channel>
</rss>
