<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>码农Joseph</title>
    <link>https://zhangxuesong.github.io/</link>
    <description>Recent content on 码农Joseph</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，转载请注明 码农Joseph 和出处链接。</copyright>
    <lastBuildDate>Mon, 14 Dec 2020 15:14:51 +0800</lastBuildDate><atom:link href="https://zhangxuesong.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>通道的高级玩法</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_channel2/</link>
      <pubDate>Mon, 14 Dec 2020 15:14:51 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_channel2/</guid>
      <description>单向通道 我们通常说通道都是指双向通道，即：即可以发也可以收的通道。 所谓单向通道就是 只能发不能收 或者 只能收不能发 的通道。一个通道是单向还是双向</description>
    </item>
    
    <item>
      <title>通道的基本操作</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_channel/</link>
      <pubDate>Sun, 13 Dec 2020 15:17:24 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_channel/</guid>
      <description>作为 Go 语言最具特色的数据类型，通道（channel）完全可以与 goroutine （协程）并驾齐驱，共同代表 Go 语言独有的并发编程模式和编程哲学。 Don’t communicate by</description>
    </item>
    
    <item>
      <title>字典的操作和约束</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_map/</link>
      <pubDate>Sat, 12 Dec 2020 11:33:51 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_map/</guid>
      <description>Go 语言的字典（map）类型 字典存储的不再是单一值，而是键值对的集合。 字典的键类型会受到约束 Go 语言的字典类型其实是一个哈希表（hash tabl</description>
    </item>
    
    <item>
      <title>container包中的那些容器</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_container/</link>
      <pubDate>Fri, 11 Dec 2020 12:23:21 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_container/</guid>
      <description>container/list Go 语言的链表实现在标准库的 container/list 代码包中。该包有两个公开的程序实体：List 和 Element，List 实现了一个双向链表，Element 代表了</description>
    </item>
    
    <item>
      <title>数组和切片</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_array_slice/</link>
      <pubDate>Thu, 10 Dec 2020 14:50:38 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_array_slice/</guid>
      <description>Go 语言的数组（array）类型和切片（slice）类型 它们的共同点是都属于集合类的类型，都可以用来存储一种类型的值。 不同的是数组的长度是固定</description>
    </item>
    
    <item>
      <title>Go 语言中的类型断言那些事儿</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_type_assertion/</link>
      <pubDate>Wed, 09 Dec 2020 16:34:11 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_type_assertion/</guid>
      <description>怎样判断一个变量的类型 先来看一段代码： package main import &amp;#34;fmt&amp;#34; var container = []string{&amp;#34;0&amp;#34;, &amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;} func main() { container := map[int]string{0: &amp;#34;0&amp;#34;, 1: &amp;#34;1&amp;#34;, 2: &amp;#34;2&amp;#34;} fmt.Printf(&amp;#34;the element is %q.\n&amp;#34;, container[1]) } 怎样在打印期中元素之前判断 container 的类型呢，当然是用类</description>
    </item>
    
    <item>
      <title>Go 语言中的作用域那些事儿</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_scope/</link>
      <pubDate>Wed, 09 Dec 2020 15:43:38 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_scope/</guid>
      <description>作用域是什么 一个程序实体被写出来，就是为了让其他程序引用。哪里的代码可以引用它呢，这就涉及到了它的作用域。 Go 语言的访问权限有三种：包级私有的</description>
    </item>
    
    <item>
      <title>Go 语言中的变量那些事儿</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_var/</link>
      <pubDate>Wed, 09 Dec 2020 09:23:22 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_var/</guid>
      <description>变量声明 除了 var name string 这种声明方式以外还有两种基于类型推断的声明方式。 注意短变量声明只能在函数体内部使用。 类型推断 类型推断是编程语言在编译器自动</description>
    </item>
    
    <item>
      <title>库源码文件和代码拆分</title>
      <link>https://zhangxuesong.github.io/posts/gocore/lib_source/</link>
      <pubDate>Tue, 08 Dec 2020 13:12:08 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/lib_source/</guid>
      <description>什么是库源码文件 库源码文件是不能直接运行的源码文件，它仅提供程序实体以供其他代码使用。如： package lib5 import &amp;#34;fmt&amp;#34; func Hello(name string) { fmt.Printf(&amp;#34;Hello %s!\n&amp;#34;, name) } 把上面代码保存到 libSource.go 执行 go run</description>
    </item>
    
    <item>
      <title>命令源码文件和 flag 库</title>
      <link>https://zhangxuesong.github.io/posts/gocore/command_source/</link>
      <pubDate>Mon, 07 Dec 2020 14:05:35 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/command_source/</guid>
      <description>前言 写了N年代码，只知道源码文件，原来细分的话源码文件也有区分，如： 命令源码文件 库源码文件 测试源码文件 他们也有不同的用途和规则。 命令源码文件</description>
    </item>
    
  </channel>
</rss>
