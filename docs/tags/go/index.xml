<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 码农Joseph</title>
    <link>https://zhangxuesong.github.io/tags/go/</link>
    <description>Recent content in Go on 码农Joseph</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，转载请注明 码农Joseph 和出处链接。</copyright>
    <lastBuildDate>Thu, 17 Dec 2020 16:59:29 +0800</lastBuildDate><atom:link href="https://zhangxuesong.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 语言及其执行规则 2</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_goroutine2/</link>
      <pubDate>Thu, 17 Dec 2020 16:59:29 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_goroutine2/</guid>
      <description>怎样让主 goroutine 等待其他 goroutine 一旦主 goroutine 执行完毕，当前的 Go 程序就会结束运行，无论其他的 goroutine 是否已经在运行了。很多时候我们需要等待其他的 goroutine 的执行结果才让主 goroutine</description>
    </item>
    
    <item>
      <title>Go 语言及其执行规则</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_goroutine/</link>
      <pubDate>Thu, 17 Dec 2020 15:32:58 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_goroutine/</guid>
      <description>Don’t communicate by sharing memory; share memory by communicating. 从 Go 语言编程的角度解释，这句话的意思是：不要通过共享数据来通讯，要以通讯的方式来共享数据。 通道（channel）类</description>
    </item>
    
    <item>
      <title>指针的有限操作</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_pointer/</link>
      <pubDate>Thu, 17 Dec 2020 09:06:50 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_pointer/</guid>
      <description>先来看一段代码： type Dog struct { name string } func (dog *Dog) SetName(name string) { dog.name = name } 对于基本类型 Dog 来说，*Dog 就是它的指针类型。而对于一个 Dog 类型，值不为 nil 的变量 dog，取址</description>
    </item>
    
    <item>
      <title>接口类型的合理运用</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_interface/</link>
      <pubDate>Wed, 16 Dec 2020 16:14:01 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_interface/</guid>
      <description>接口的基础知识 接口类型与其他数据类型不同，它是没办法初始化的。具体的说，我们不能通过 new 或者 make 函数创建出一个接口类型的值，也无法用字面量来表示</description>
    </item>
    
    <item>
      <title>结构体及其方法</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_struct/</link>
      <pubDate>Wed, 16 Dec 2020 09:10:06 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_struct/</guid>
      <description>结构体类型基础知识 结构体表示的是实实在在的数据结构。一个结构体类型可以包含若干个字段，每个字段通常都需要有确切的名字和类型。 结构体也可以不包</description>
    </item>
    
    <item>
      <title>函数的正确使用姿势</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_func/</link>
      <pubDate>Tue, 15 Dec 2020 10:08:40 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_func/</guid>
      <description>函数是一等公民 在 Go 语言中，函数可是一等的（first-class）公民，函数类型也是一等的数据类型。 简单来说，这意味着函数不但可以用于封装代</description>
    </item>
    
    <item>
      <title>通道的高级玩法</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_channel2/</link>
      <pubDate>Mon, 14 Dec 2020 15:14:51 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_channel2/</guid>
      <description>单向通道 我们通常说通道都是指双向通道，即：即可以发也可以收的通道。 所谓单向通道就是 只能发不能收 或者 只能收不能发 的通道。一个通道是单向还是双向</description>
    </item>
    
    <item>
      <title>通道的基本操作</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_channel/</link>
      <pubDate>Sun, 13 Dec 2020 15:17:24 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_channel/</guid>
      <description>作为 Go 语言最具特色的数据类型，通道（channel）完全可以与 goroutine （协程）并驾齐驱，共同代表 Go 语言独有的并发编程模式和编程哲学。 Don’t communicate by</description>
    </item>
    
    <item>
      <title>字典的操作和约束</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_map/</link>
      <pubDate>Sat, 12 Dec 2020 11:33:51 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_map/</guid>
      <description>Go 语言的字典（map）类型 字典存储的不再是单一值，而是键值对的集合。 字典的键类型会受到约束 Go 语言的字典类型其实是一个哈希表（hash tabl</description>
    </item>
    
    <item>
      <title>container包中的那些容器</title>
      <link>https://zhangxuesong.github.io/posts/gocore/go_container/</link>
      <pubDate>Fri, 11 Dec 2020 12:23:21 +0800</pubDate>
      
      <guid>https://zhangxuesong.github.io/posts/gocore/go_container/</guid>
      <description>container/list Go 语言的链表实现在标准库的 container/list 代码包中。该包有两个公开的程序实体：List 和 Element，List 实现了一个双向链表，Element 代表了</description>
    </item>
    
  </channel>
</rss>
